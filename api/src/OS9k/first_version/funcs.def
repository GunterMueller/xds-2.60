(* funcs.def  Feb 27  12:36:51  2000 *)
(* Generated by H2D v1.31.0 from funcs.h. *)
<*+ M2ADDTYPES *>
<*+ M2EXTENSIONS *>
<*+ NOHEADER *> 
<* IF NOT DEFINED(GENTYPEDEF) THEN *> <* NEW GENTYPEDEF+ *> <* END *>

DEFINITION MODULE ["C"] funcs;

IMPORT SYSTEM;
(* H2D:  Required IMPORT clause: 
IMPORT funcs;
*)

CONST 
  F_ALARM = 1;   (*  F$Alarm: Alarm system requests  *)
  F_ALLPRC = 2;   (*  F$AllPrc: Allocate Process Descriptor  *)
  F_ALLTSK = 3;   (*  F$AllTsk: Allocate Task  *)
  F_APROC = 4;   (*  F$AProc: Enter Active Process Queue  *)
  F_CCTL = 5;   (*  F$CCtl: cache control  *)
  F_CHKMEM = 6;   (*  F$ChkMem: check memory accessibility (spu)  *)
  F_CLRSIGS = 7;   (*  F$ClrSigs: clear signals from a process  *)
  F_CMPNAM = 8;   (*  F$CmpNam: Compare Two Names  *)
  F_CPYMEM = 9;   (*  F$CpyMem: Copy External Memory  *)
  F_CRC = 10;   (*  F$CRC: Generate CRC  *)
  F_DATMOD = 11;   (*  F$DatMod: Create data module  *)
  F_DEXEC = 12;   (*  F$DExec: Debugging execution call (single step)  *)
  F_DEXIT = 13;   (*  F$DExit: Debugging exit call (kill child)  *)
  F_DELTSK = 14;   (*  F$DelTsk: Delete task call  *)
  F_DFORK = 15;   (*  F$DFork: Debugging Fork call  *)
  F_EVENT = 16;   (*  F$Event: Create/Link to named event  *)
  F_EXIT = 17;   (*  F$Exit: Terminate Process  *)
  F_FINDPD = 18;   (*  F$FindPD: Find Process/Path Descriptor  *)
  F_FMOD = 19;   (*  F$FMod: find module directory entry  *)
  F_GBLKMP = 20;   (*  F$GBlkMp: get System Block Map copy  *)
  F_GMODDR = 21;   (*  F$GModDr: get Module Directory copy  *)
  F_GPRDSC = 22;   (*  F$GPrDsc: get Process Descriptor copy  *)
  F_GPRDBT = 23;   (*  F$GPRDBT: get Process Table Block  *)
  F_GREGOR = 25;   (*  F$Gregor: Convert julian date to gregorian date  *)
  F_ID = 26;   (*  F$ID: Return Process ID  *)
  F_ICPT = 27;   (*  F$Icpt: Set Signal Intercept  *)
  F_INITDATA = 28;   (*  New Call: Initialize static storage  *)
  F_IRQ = 29;   (*  F$IRQ: Enter IRQ Polling Table  *)
  F_JULIAN = 30;   (*  F$Julian: Convert gregorian to Julian date  *)
  F_MEM = 31;   (*  F$Mem: Set Memory Size  *)
  F_LINK = 32;   (*  F$Link: Link to Module  *)
  F_LOAD = 33;   (*  F$Load: Load Module from File  *)
  F_MOVE = 34;   (*  F$Move: Move Data (low bound first)  *)
  F_TIME = 35;   (*  F$Time: Get Current Time  *)
  F_UNLINK = 36;   (*  F$UnLink: Unlink Module  *)
  F_UNLOAD = 37;   (*  F$UnLoad: Unlink Module by name  *)
  F_NPROC = 38;   (*  F$NProc: Start Next Process  *)
  F_CHAIN = 39;   (*  F$Chain: Chain Process to New Module  *)
  F_FORK = 40;   (*  F$Fork: Start New Process  *)
  F_GETSYS = 41;   (*  F$GetSys: Examine system global variable  *)
  F_PERR = 42;   (*  F$PErr: Print Error  *)
  F_PERMIT = 43;   (*  F$Permit: SPU grant memory access permissions  *)
  F_PROTECT = 44;   (*  F$Protect: SPU protect memory  *)
  F_PRSNAM = 45;   (*  F$PrsNam: Parse Pathlist Name  *)
  F_RETPD = 46;   (*  F$RetPD: Return Process/Path Descriptor  *)
  F_RTE = 47;   (*  F$RTE: Return from Intercept routine  *)
  F_SEND = 48;   (*  F$Send: Send Signal to Process  *)
  F_SETCRC = 49;   (*  F$SetCRC: Generate valid header and CRC in module  *)
  F_STIME = 50;   (*  F$STime: Set Current Time  *)
  F_SPRIOR = 51;   (*  F$SPrior: Set Process Priority  *)
  F_SUSER = 52;   (*  F$SUser: Set User ID number  *)
  F_SIGMASK = 53;   (*  F$SigMask: set signal mask  *)
  F_SLEEP = 54;   (*  F$Sleep: Suspend Process  *)
  F_SRQMEM = 55;   (*  F$SRqMem: System Memory Request  *)
  F_SRTMEM = 56;   (*  F$SRtMem: System Memory Return  *)
  F_SSVC = 57;   (*  F$SSvc: Service Request Table Initialization  *)
  F_STRAP = 58;   (*  F$STrap: Set Trap Intercept  *)
  F_SSPD = 59;   (*  F$SSpd: Suspend Process  *)
  F_SYSDBG = 60;   (*  F$SysDbg: Invoke system level debugger  *)
  F_SYSID = 61;   (*  F$SYSID: Get system id  *)
  F_TLINK = 62;   (*  F$TLink: Link trap subroutine package  *)
  F_TEXIT = 63;   (*  F$TExit: Exit trap handler terminate routine  *)
  F_UACCT = 64;   (*  F$UAcct: inform user accounting of process status  *)
  F_VMODUL = 65;   (*  F$VModul: Validate Module  *)
  F_WAIT = 66;   (*  F$Wait: Wait for Child Process to Die  *)
  F_MKMDIR = 67;   (*  New Call: Make module directory  *)
  F_CHMDIR = 68;   (*  New Call: Change current module directory  *)
  F_DELMDIR = 69;   (*  New Call: Delete module directory  *)
  F_CMDPERM = 70;   (*  New Call: Change module directory permissions  *)
  F_ALTMDIR = 71;   (*  New Call: Set alternate module directory  *)
  F_SLINK = 72;   (*  New Call: Link to subroutine library  *)
  F_GETMDP = 73;   (*  New Call: Get module directory pathlists  *)
  F_FORKM = 74;   (*  New Call: Fork module by pointer  *)
  F_CHAINM = 75;   (*  New Call: Chain module by pointer  *)
  F_DFORKM = 76;   (*  New Call: Debug fork module by pointer  *)
  F_LINKM = 77;   (*  New Call: Link to module by pointer  *)
  F_SLINKM = 78;   (*  New Call: Subroutine library link by pointer  *)
  F_TLINKM = 79;   (*  New Call: Trap handler link by pointer  *)
  F_MODADDR = 80;   (*  New Call: Get module address from a pointer  *)
  F_SETSYS = 81;   (*  New Call: Set system global variable  *)
  F_SIGRESET = 82;   (*  New Call: Reset intercept recursion depth to 0  *)
  F_VPERMIT = 83;   (*  New Call: Map logical address space to physical  *)
  F_SIGRS = 84;   (*  New Call: Resize signal queue block (expand)  *)
  F_FINDFREE = 85;   (*  New Call: Find free space in user address map  *)
  F_TRANSADD = 86;   (*  New Call: Translate an address  *)
  F_EXPEVT = 87;   (*  New Call: Expand event table  *)
  F_EXPPRT = 88;   (*  New Call: Expand process descriptor table  *)
  F_CRYPT = 89;   (*  New Call: Data encryption services  *)
  F_CONFIG = 90;   (*  New Call: System configuration wildcard call  *)
  F_SIGLNGJ = 91;   (*  New Call: Set signal mask and pop stack image  *)
  F_ABORT = 92;   (*  New Call: Abort process (like an exception)  *)
  F_DATTACH = 94;   (*  New Call: Attach to debug process  *)
  F_MBUF = 95;   (*  F$MBuf: Memory buffer manager call  *)
  F_SEMA = 96;   (*  New Call: Reserve/Release semaphore  *)
  F_HLPROTO = 97;   (*  New Call: High level protocal manager  *)
  F_PWRMAN = 98;   (*  New Call: Power management  *)
  F_FLASH = 99;   (*  New Call: Flash memory management  *)
  I_ORG = 128;   (*  start of i/o system calls  *)
  I_ALLPD = 128;   (*  New Call: Allocate Path Descriptor  *)
  I_GETPD = 129;   (*  New Call: Get Path Descriptor  *)
  I_IODEL = 130;   (*  New Call: Check if I/O module in use  *)
  I_RETPD = 131;   (*  New Call: Return Path Descriptor  *)
  I_IOFORK = 132;   (*  New call: Set up I/O for process  *)
  I_IOEXIT = 133;   (*  New call: Clean up I/O for process  *)
  F_CRLK = 134;   (*  New call: Create resource lock  *)
  F_ACQLK = 135;   (*  New call: Acquire resource lock  *)
  F_CAQLK = 136;   (*  New call: Conditionally acquire resource lock  *)
  F_RELLK = 137;   (*  New call: Release resource lock  *)
  F_DELLK = 138;   (*  New call: Delete resource lock  *)
  F_DDLK = 139;   (*  New call: Detect resource deadlock  *)
  I_GIOPROC = 140;   (*  New call: Get pointer to I/O process descriptor  *)
  I_CIOPROC = 141;   (*  New call: Get copy of I/O process descriptor  *)
  I_TRANPN = 142;   (*  New call: Translate user path number  *)
  F_WAITLK = 143;   (*  New call: Wait on resource lock  *)
  I_ALIAS = 144;   (*  New call: Alias pathlist  *)
  I_SGETSTAT = 145;   (*  I$SGStat: System path getstat  *)
  I_RDALST = 146;   (*  New call: Read pathlist alias list  *)
  I_GETDL = 147;   (*  New call: Get system I/O device list pointer  *)
  I_EXPIOPT = 148;   (*  New call: Expand IO process descriptor table  *)
  I_ATTACH = 150;   (*  I$Attach: Attach I/O Device  *)
  I_CHGDIR = 151;   (*  I$ChgDir: Change Default Directory  *)
  I_CLOSE = 152;   (*  I$Close: Close Path  *)
  I_CREATE = 153;   (*  I$Create: Create New File  *)
  I_DELETE = 154;   (*  I$Delete: Delete File  *)
  I_DETACH = 155;   (*  I$Detach: Detach I/O Device  *)
  I_DUP = 156;   (*  I$Dup: Duplicate Path  *)
  I_GETSTAT = 157;   (*  I$GetStt: Get Path Status  *)
  I_MAKDIR = 158;   (*  I$MakDir: Make Directory File  *)
  I_OPEN = 159;   (*  I$Open: Open Existing File  *)
  I_READ = 160;   (*  I$Read: Read Data  *)
  I_READLN = 161;   (*  I$ReadLn: Read Line of ASCII Data  *)
  I_SEEK = 162;   (*  I$Seek: Change Current Position  *)
  I_SETSTAT = 163;   (*  I$SetStt: Set Path Status  *)
  I_WRITE = 164;   (*  I$Write: Write Data  *)
  I_WRITLN = 165;   (*  I$WritLn: Write Line of ASCII Data  *)
  I_CONFIG = 166;   (*  New Call: Configure I/O system wildcard call  *)
  I_SLM = 167;   (*  New Call: Visual analyzer system call  *)
  EV_LINK = 0;   (*  Ev$Link: Link to event  *)
  EV_UNLNK = 1;   (*  Ev$UnLnk: Unlink from event  *)
  EV_CREAT = 2;   (*  Ev$Creat: Create an event  *)
  EV_DELET = 3;   (*  Ev$Delet: Delete event  *)
  EV_WAIT = 4;   (*  Ev$Wait: Wait for event  *)
  EV_WAITR = 5;   (*  Ev$WaitR: Wait for relative event  *)
  EV_READ = 6;   (*  Ev$Read: Read event value  *)
  EV_INFO = 7;   (*  Ev$Info: Read event information  *)
  EV_SIGNL = 8;   (*  Ev$Signl: Signal event  *)
  EV_PULSE = 9;   (*  Ev$Pulse: Pulse event value  *)
  EV_SET = 10;   (*  Ev$Set: Set event value  *)
  EV_SETR = 11;   (*  Ev$Incr: Set relative event  *)
  EV_ANYSET = 12;   (*  Ev$AnySet: Wait for any bits to become set  *)
  EV_ALLSET = 13;   (*  Ev$AllSet: Wait for all bits to become set  *)
  EV_ANYCLR = 14;   (*  Ev$AnyClr: Wait for any bits to become clear  *)
  EV_ALLCLR = 15;   (*  Ev$AllClr: Wait for all bits to become clear  *)
  EV_TSTSET = 16;   (*  Ev$TstSet: Wait for all bits to clear, then set them  *)
  EV_CHANGE = 17;   (*  Ev$Change: Wait for any bits to change  *)
  EV_SETOR = 18;   (*  Ev$SetOr: Set value by oring it with mask  *)
  EV_SETAND = 19;   (*  Ev$SetAnd: Set value by anding it with mask  *)
  EV_SETXOR = 20;   (*  Ev$SetXOr: Set value by xoring it with mask  *)

(*  F_ALARM/F_SALARM subcode definitions:  *)

CONST 
  A_DELET = 0;   (*  A$Delet: Delete alarm  *)
  A_SET = 1;   (*  A$Set: Set alarm  *)
  A_CYCLE = 2;   (*  A$Cycle: set cyclic alarm  *)
  A_ATIME = 3;   (*  A$AtTime: set alarm at absolute time  *)
  A_RESET = 4;   (*  New Call: reset/reschedule an existing alarm  *)

(*  I_CONFIG subcode definitions:  *)

CONST 
  IC_PATHSZ = 1;   (*  New Call: increase processes total path size  *)
  FND_FROMTOP = 0;   (*  New Call: search for free space from top  *)
  FND_FROMBOT = 1;   (*  New Call: search for free space from bottom  *)
  T_SYS2PHYS = 0;   (*  New Call: xlate system address to physical  *)
  T_SYS2USR = 1;   (*  New Call: xlate system address to user  *)
  T_USR2SYS = 2;   (*  New Call: xlate user address to system  *)
  T_USR2PHYS = 3;   (*  New Call: xlate user address to physical  *)
  T_PHYS2SYS = 4;   (*  New Call: xlate physical address to system  *)
  T_PHYS2USER = 5;   (*  New Call: xlate physical address to user  *)

END funcs.
