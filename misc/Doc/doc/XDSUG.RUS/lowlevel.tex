\chapter{Низкоуровневое программирование}\label{lowlevel}
\index{низкоуровневое программирование}

\section{Представление данных}\label{lowlevel:datarep}

Внутреннее представление значений основных типов языков
Модула-2 и Оберон-2 дано в таблицах
\ref{table:m2:rep} и \ref{table:o2:rep}. 
В таблице \ref{table:system:rep} дано представление системных типов.

\begin{table}
\begin{tabular}{|l|c|l|} \hline
\bf Модула-2  тип  & \bf Бит &\bf представление \\ \hline
\tt SHORTINT       & 8     & знаковое \\
\tt INTEGER        & 16/32 & знаковое (см. \ref{lowlevel:datarep:whole})\\
\tt LONGINT        & 32    & знаковое \\
\tt SHORTCARD      & 8     & беззнаковое \\
\tt CARDINAL       & 16/32 & беззнаковое (см. \ref{lowlevel:datarep:whole})\\
\tt LONGCARD       & 32    & беззнаковое \\
\tt CHAR           & 8     & беззнаковое \\
\tt BOOLEAN        & 8/32  & беззнаковое (см. \ref{lowlevel:datarep:bool})\\
                   &       & 0 для FALSE, 1 для TRUE \\
\tt subranges      &       & как базовый тип \\
\tt REAL           & 32    & формат 80x87 одинарной точности \\
\tt LONGREAL       & 64    & формат 80x87 двойной точности \\
\tt LONGLONGREAL   & 80    & формат 80x87 увеличенной точности \\
\hline
\end{tabular}
\caption{Представление основных типов Модулы-2}\label{table:m2:rep}
\end{table}

\begin{table}
\begin{tabular}{|l|c|l|} \hline
\bf Оберон-2  тип  & \bf Бит &\bf представление \\ \hline
\tt SHORTINT       & 8        & знаковое \\
\tt INTEGER        & 16       & знаковое \\
\tt LONGINT        & 32       & знаковое \\
\tt CHAR           & 8        & беззнаковое \\
\tt BOOLEAN        & 8        & беззнаковый байт \\
                   &          & 0 для FALSE, 1 для TRUE \\
\tt REAL           & 32    & формат 80x87 одинарной точности \\
\tt LONGREAL       & 64    & формат 80x87 двойной точности \\
\tt LONGLONGREAL   & 80    & формат 80x87 увеличенной точности \\
\tt SET            & 32       & упакованное множество \\
\hline
\end{tabular}
\caption{Представление основных типов Оберона-2}\label{table:o2:rep}
\end{table}

\begin{table}
\begin{tabular}{|l|c|l|} \hline
\bf Системный тип & \bf Бит  &\bf Представление \\ \hline
\tt ADDRESS      & 32    & беззнаковое   \\
\tt BOOL8        & 8     & беззнаковое \\
\tt BOOL16       & 16     & беззнаковое \\
\tt BOOL32       & 32    & беззнаковое \\
\tt BYTE         & 8     & беззнаковое  \\
\tt CARD8        & 8     & беззнаковое \\
\tt CARD16       & 16    & беззнаковое \\
\tt CARD32       & 32    & беззнаковое \\
\tt INT8         & 8     & знаковое \\
\tt INT16        & 16    & знаковое \\
\tt INT32        & 32    & знаковое \\
\tt LOC          & 8     & беззнаковое  \\
\tt WORD         & 32    & ARRAY [0..3] OF LOC  \\
\hline
\end{tabular}
\caption{Представление типов из SYSTEM}\label{table:system:rep}
\end{table}

\subsection{INTEGER и CARDINAL типы Модулы-2}\label{lowlevel:datarep:whole}

Если опция \OERef{M2BASE16} выключена (OFF), то типы INTEGER и CARDINAL 
представляются 32-битовыми значениями, иначе 16-битовыми.

\subsection{BOOLEAN тип Модулы-2}\label{lowlevel:datarep:bool}

Тип BOOLEAN представляется беззнаковым 1-байтовым значением.

\subsection{Перечислимые типы Модулы-2}

Представление перечислимых типов зависит от текущего значения
параметра \OERef{ENUMSIZE}. Если значения перечислимого типа
помещаются в заданный этим параметром размер (1, 2 или 4 байта),
то под них отводится это количество байтов; в противном случае
выбирается наименьшее подходящее количество.

\subsection{Типы множеств Модулы-2}

Множества представляются как массивы битов. Параметр \OERef{SETSIZE}
задает размер для маленьких множеств (1, 2 или 4 байта).

Если опция \OERef{M2BASE16} выключена (OFF), то тип {\tt BITSET} 
представляется беззнаковыми 32-битовыми значениями, иначе --- 16-битовыми.

\subsection{Типы указателя, адреса и скрытые типы}

Адресные типы представляются 32-битовыми (4-байтовыми) беззнаковыми
значениями, указывающими сдвиг в байтах в сегменте данных задачи.
Адресная арифметика реализована как 32-битовая беззнаковая
арифметика без проверок на переполнение.

\subsection{Процедурные типы}

Значение процедурного типа представляется 32-битовым (4-байтовым)
адресом точки входа процедуры в сегменте кода задачи.

\subsection{Записи}\label{lowlevel:recrep}

Запись представляется непрерывным сегментом памяти, содержащим все
поля записи, представленные в соответствии с их типами. Компилятор
выравнивает поля в соответствии с их размерами и с текущим значением
параметра выравнивания \OERef{ALIGNMENT}, которое может быть равно 
1, 2, 4 или 8.
Поле, размер которого, округленный до ближайшей степени двойки, не 
превосходит параметра выравнивания, имеет сдвиг, кратный его 
(округленному) размеру. Сдвиги полей большего размера кратны параметру
выравнивания. Вариантные части выравниваются по их наибольшему полю. %???
Размер всей записи округляется до ближайшего кратного выравниванию.

\subsection{Массивы}\label{lowlevel:opendesc}

Массив представляется непрерывным сегментом памяти, содержащим все
элементы массива, представленные в соответствии с их типами. 

Элементы внутри массива также выравниваются, поэтому в общем случае
для массива
\begin{verbatim}
  TYPE A = ARRAY [0..N-1] OF T;
\end{verbatim}
{\tt SIZE(A)} не обязательно равен {\tt SIZE(T) * N}.

Открытые массивы и формальные параметры типа
{\tt ARRAY OF ... ARRAY OF T} представляются дескриптором открытого массива.
Дескриптор $N$-мерного открытого массива --- это массив из
$2N$ 32-битовых элементов следующего вида:
\begin{itemize}
\item   первый элемент --- адрес самого массива
\item   второй --- длина в последней размерности
\item
по два элемента для каждой из $N-1$ предыдущих размерностей:
размер в байтах массива следующей размерности и длина в данной
размерности
\end{itemize}

\paragraph{Пример:} пусть {\tt A} --- открытый $3$-мерный массив
элементов типа
{\tt INTEGER} ({\tt SIZE(INTEGER)=2} в Обероне-2), созданный 
оператором

\verb'    NEW(A,4,3,6)'.

Тогда его дескриптор есть 6-элементный массив, содержащий:

\begin{verbatim}
     #0:  Адрес самого массива
     #1:   6
     #2:  12   (6*2)
     #3:   3   
     #4:  36   (12*3)
     #5:   4
\end{verbatim}

\section{SEQ-параметры}\label{lowlevel:seqrep}  % !!! Remove ?

Массив байтов, передаваемый в формальный SEQ-параметр процедуры,
устроен следующим образом:
\begin{itemize}
\item
Значения всех фактических параметров, образующих последовательность,
представляются в виде, описанном ниже, и объединяются в один массив 
в порядке их перечисления
\item 
целочисленные значения конвертируются в LONGINT
\item BOOLEAN, CHAR, натуральные и перечислимые значения
конвертируются в LONGCARD
\item значения типа диапазона обрабатываются в соответствии с их базовыми
типами
\item 
вещественные значения конвертируются в LONGREAL
\item 
значения типа указателя, адреса, процедуры и скрытых типов
конвертируются в ADDRESS
\item
структурное значение (массив или запись) интерпретируется как %??? открытый
одномерный массив байтов, и представляется дескриптором этого массива
(см. \ref{lowlevel:datarep}).
\end{itemize}

\Example
\begin{verbatim}
    PROCEDURE write(SEQ args: SYSTEM.BYTE);
    BEGIN
    END write;

    VAR i: INTEGER;
        c: SYSTEM.CARD8;
        r: LONGREAL;
        S: RECORD a: LONGINT; c: CHAR END;
        p: POINTER TO ARRAY OF CHAR;
    ...

    write(i,c,S,r,p^);
\end{verbatim}

Для этого вызова, фактический массив байтов, переданный {\tt write},
будет содержать:
\begin{itemize}
\item  4 байта расширенного знаком значения {\tt i}
\item  4 байта расширенного нулем значения {\tt c}
\item  12 байтов дескриптора массива:
\begin{itemize}
    \item 4 байта, содержащие адрес {\tt S}
    \item 4 байта, содержащие 0
    \item 4 байта, содержащие 4 ({\tt SIZE(S)-1})
\end{itemize}
\item  8 байтов значения {\tt r} в формате 80387 двойной точности
\item  12 байтов дескриптора массива:
\begin{itemize}
    \item 4 байта, содержащие адрес самого массива ARRAY OF CHAR
    \item 4 байта, содержащие 0
    \item 4 байта, содержащие \verb|SIZE(p^)-1|
\end{itemize}
\end{itemize}


\section{Соглашения об именах и связях}

В этом разделе описываются соглашения об именах и связях для
Модулы-2, Оберона-2 и иноязычных процедур.

\subsection{Общие соглашения} %??? considerations

Все параметры всегда передаются через стек. Количество байтов, 
занимаемых одним параметром, всегда кратно 4. Старшие байты
параметров более коротких типов (напр. CHAR, SYSTEM.CARD16) 
не определены.

Параметры по значению скалярных типов (булевых,
CHAR, целых, вещественных, указателей и процедурных типов)
и типа множества размера до 32 бит помещаются непосредственно на стек.
Параметр по значению комплексного типа передается как два 
вещественных.

Параметры по значению всех остальных типов (даже одноэлементного 
массива CHAR) передаются по ссылке. Процедура сама должна скопировать
на стек свои нескалярные параметры по значению, кроме параметров 
по чтению.

{\bf Предупреждение:} В C, за копирование параметров по значению
структурных типов на стек отвечает {\em вызывающий}, а не сама процедура.
Для таких процедур следует создавать промежуточную C функцию,
принимающую эти параметры по ссылке. К счастью, такие случаи 
очень редки.

{\bf Замечание:} При вызове иноязычной процедуры вида "SysCall"
количество 4-байтовых слов, положенных на стек,
записывается в регистр AL. 

\subsection{Открытые массивы}

Для процедур языков Модула-2 и Оберон-2
вместо параметра типа N-мерного открытого массива фактически 
передается N+1 параметр: адрес массива и его длины во всех размерностях,
слева направо. Для иноязычных процедур передается только адрес массива.

\subsection{Обероновские записи}

Для VAR-параметра типа Оберон-2 записи передаются адрес записи и
адрес ее динамического дескриптора типа.

\subsection{Результат функции}

Если функция возвращает нескалярный результат, то ей передается
еще один дополнительный параметр: адрес временной переменной,
в которую нужно поместить этот результат.
{\bf Замечание:} Это соглашение может быть несовместимо с C.

Результат комплексного типа возвращается как запись с двумя
вещественными полями.

\subsection{Вложенные процедуры}

Вложенной процедуре на языке Модула-2 или Оберон-2, которая обращается
к контексту содержащей ее процедуры, передается дополнительный параметр:
{\em база} этой процедуры. Точнее, процедуре передаются базы
всех объемлющих процедур, к контекстам которых обращается она сама или
какая-либо  из ее вложенных процедур.

База процедуры --- это адрес на стеке, по которому лежит адрес возврата
процедуры.

\subsection{Получатели в Обероне-2}

Методу Оберона-2 передается дополнительный параметр --- получатель.
Если получатель описан как VAR-параметр, то передается также ссылка
на его динамический дескриптор типа.

\subsection{SEQ-параметры}

Для Модула-2/Оберон-2 процедур, фактические параметры, соответствующие 
SEQ-параметру, записываются во временную переменную, которая затем 
передается как ARRAY OF BYTE
(т.е. передаются ее адрес и размер). Для иноязычных процедур 
используется C-совместимый подход: параметры складываются на стек.
В любом случае, все целочисленные параметры расширяются до 4 байт,
параметры типа REAL --- до LONGREAL,
нескалярные параметры передаются по ссылке.

\subsection{Порядок параметров}

Общий порядок параметров (любая из категорий может быть пустой):

\begin{itemize}
\item адрес временной переменной для хранения результата % !!! references
\item базы объемлющих процедур
\item получатель (только для методов в Обероне-2)
\item обычные параметры
\item SEQ-параметр
\end{itemize}

Для всех процедур, кроме иноязычных \verb'"Pascal"'-процедур,
порядок загрузки на стек --- справа налево, т.е. первым кладется на стек
SEQ-параметр, последним --- адрес результата.

\subsection{Очистка стека}

Участок стека, аллоцированный для параметров, должен быть 
освобожден при выходе из процедуры. В зависимости от языка, это
делается либо вызвавшей процедурой
("C" и "SysCall"), либо самой вызванной процедурой (Модула-2, Оберон-2,
"StdCall", "Pascal").

\subsection{Использование регистров}

Процедура должна сохранить значения регистров ESI, EDI, EBP и EBX,
сохранить выполнение равенства ES=DS, и очистить флаг D.

Стек FPU должен быть пуст при вызове процедуры, и после выхода из нее.
Исключением являются процедуры, возвращающие результат типа REAL или
LONGREAL.  Для них, результат помещается в ST(0).

{\bf Замечание}: Если параметр \OERef{CC} равен "WATCOM" или
"SYMANTEC", то компилятор полагает, что иноязычные "C"-процедуры
возвращают результат типа REAL в EAX, а LONGREAL --- в EAX
(младшие байты) и EDX (старшие байты).

\subsection{Соглашения об именах}

Внешние имена экспортируемых процедур в объектных модулях %??? файлах 
строятся по следующим правилам:

\begin{tabular}{lll}
\hline
\bf Соглашение & \bf Действие с именем & \bf Пример \\
\hline
"Modula"       & предваряется именем модуля и "\_" & \verb'Module_Proc' \\
"Oberon"       & то же                                 & \verb'Module_Proc' \\
"C"            & предваряется подчерком "\_" (см. замечание) & \verb'_Proc'       \\
"Pascal"       & переводится в заглавный регистр       & \verb'PROC'        \\
"StdCall"      & не меняется                             & \verb'Proc'        \\
"SysCall"      & не меняется                             & \verb'Proc'        \\
\hline
\end{tabular}

{\bf Замечание:} Если параметр \OERef{CC} равен "WATCOM",
то внешние имена иноязычных "C"-процедур 
{\em не} префиксуются подчерком.

%input{codeproc.tex} % -------------------------------
