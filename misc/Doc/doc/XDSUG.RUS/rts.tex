\chapter{Поддержка исполнения}\label{rts}
\index{Поддержка исполнения}\index{RTS}

Некоторые языковые средства реализованы в библиотеке поддержки исполнения
(Run-Time Support, RTS). Среди них:
\begin{itemize}
\ifgenc
\item   проверки во время исполнения
%???        run-time checks
\fi
\item   исключения и финализация
\item   сопрограммы
\item   распределение памяти
\item   сборка мусора
\item   посмертная история
\end{itemize}
\xds{} содержит общую для Модулы-2 и Оберона-2 библиотеку поддержки
исполнения. Это сделано ввиду того, что модули на обоих языках 
могут совместно использоваться в одном проекте. Как правило, в
исполняемую программу включаются лишь те средства из RTS, которые
в ней используются. Например, если программа написана полностью на 
Модуле-2, то обероновская часть RTS (сборка мусора, метаязыковые
средства) не будет включена.

Интегрированное распределение памяти описано в
\ref{rts:mm}. Раздел \ref{rts:oberonRTS} посвящен интерфейсу
с поддержкой исполнения для Оберона-2.

\section{Распределение памяти}\label{rts:mm}
\index{распределение памяти}
\index{сборка мусора}

Средства распределения памяти \xds{} включают:
\begin{itemize}
\item   стандартные процедуры аллокации и освобождения памяти для
Модулы-2 (см. опцию \OERef{STORAGE});
\item   процедуру аллокации памяти для Оберона-2;
\item   процедуру аллокации системной памяти для Оберона-2
        (см. \ref{o2:system:new});
\item   сборщик мусора.
\end{itemize}

Распределением памяти управляют опция \OERef{GCAUTO}
и параметры \OERef{GCTHRESHOLD} и \OERef{HEAPLIMIT}.
Их следует устанавливать при компиляции головного модуля программы\footnote{
Мы рекомендуем задавать их в проектном файле или в файле конфигурации.}.
Их значения \xds{} использует при генерации вызова инициализации RTS.

Опция \OERef{GCAUTO} разрешает неявный (автоматический) вызов сборщика мусора.
Если эта опция не выставлена, то сборщик мусора
должен вызываться в явном виде в тексте (см. \ref{rts:oberonRTS}).

Сборщик мусора автоматически вызывается процедурой аллокации
памяти в следующих случаях:
\begin{itemize}
\item  блок памяти требуемой длины не может быть выделен;
\item  объем занятой памяти превысил границу, заданную параметром
       \OERef{HEAPLIMIT};
\item  объем занятой памяти превысил границу, заданную параметром
       \OERef{GCTHRESHOLD}.
\end{itemize}
При вызове аллокации из Оберона-2, 
если память не удалось выделить даже после сборки мусора,
то возбуждается исключение.

\section{История}\label{rts:history}

Если при компиляции программы была выставлена опция \OERef{GENHISTORY},
то при ненормальном завершении программы система поддержки выдаст
стек вызовов процедур, с указанием
\begin{itemize}
\item имени файла
\item номера строки
\item значения программного счетчика %??? a program counter value
\item имени процедуры (не всегда)
\end{itemize}
{\bf Замечание:} Все модули программы для этого должны быть скомпилированы с
включенной опцией \OERef{LINENO}.

\ifgencode
Чтобы выдать историю, RTS просматривает процедурный стек сопрограммы,
вызвавшей исключение, и пытается распознать вызовы процедур. Это 
нетривиально, так как компилятор порождает сильно оптимизированный код.
В частности, не все процедуры имеют на стеке область процедурных данных.

Для каждого указателя на сегмент кода на стеке RTS проверяет предыдущую
команду. Если это --- команда вызова, то RTS считает, что это 
вызов процедуры. При этом реальные вызовы процедур вряд ли будут пропущены,
однако может найтись что-либо иное, выглядящее, как вызов. Как правило,
такие ситуации возникают из-за непроинициализированных переменных.

Первая строка истории всегда верна. Для всех остальных строк истории мы
рекомендуем проверять, действительно ли в указанной строке есть вызов
указанной процедуры.

Если при компиляции выставлена опция \OERef{GENFRAME}, то код будет 
немножко медленнее, но RTS будет сканировать области процедурных данных,
и все адреса и номера строк в истории будут {\em абсолютно} верными.
Имена процедур почти всегда определяются верно, кроме случаев, когда
в некоторых модулях нет отладочной информации --- скорее всего, в 
модулях, скомпилированных другим компилятором, или компилятором
\XDS{} без некоторых флагов отладки. Поэтому не следует слепо
доверять указанным именам процедур.

Включение опции \OERef{GENHISTORY} {\em не} замедляет код, поскольку
это лишь добавляет один вызов к процедуре инициализации.
\else % genc
{\bf Замечание:} Включение опции \OERef{GENHISTORY} приводит к замедлению
кода, поскольку транслятор добавляет в тело каждой функции дополнительный
вызов процедуры из RTS.
\fi
Опцию \OERef{GENHISTORY} следует выставлять при компиляции головного 
модуля программы: в заголовке, в командной строке компилятора, или
в проектном файле (мы рекомендуем последнее).

Пример программы и выданного стека процедур:
\begin{verbatim}
PROCEDURE P1;
  (* непроинициализированная переменная: *)
  VAR x: ARRAY [0..50] OF INTEGER;
BEGIN
  i:=i DIV j;   (* line 50 *)
END P1;

PROCEDURE P2;
BEGIN
  i:=i DIV j;   (* line 100 *)
END P2;

PROCEDURE P3;
BEGIN
  P1;           (* line 150 *)
END P3;
\end{verbatim}

\begin{verbatim}
#RTS: Нет обработчика исключения #6: нулевой или отрицательный делитель
------------------------------------------------------------
Source file                        LINE  OFFSET  PROCEDURE
------------------------------------------------------------
"test.mod"                           50 000000DE
"test.mod"                          100 0000024C
"test.mod"                          150 0000051D
\end{verbatim}
Из текста программы видно, что процедура 
P1 не может быть вызвана из
P2. Вторая строка истории --- лишняя.

\section{Модуль oberonRTS}\label{rts:oberonRTS}
\index{поддержка исполнения (Оберон)}

Средства поддержки исполнения (RTS) --- существенная часть реализации
языка \ot{}. Они включают: активацию команд, выделение памяти,
сборку мусора и метаязыковые средства. 
Модуль {\bf oberonRTS} предоставляет интерфейс к этим средствам.
\lindex{oberonRTS}

\subsection{Типы и переменные}
\begin{verbatim}
TYPE
  Module;  (* структура данных для модуля *)
  Type;    (* структура данных для типа *)
  Command = PROC; (* процедура без параметров *)
  CARDINAL = SYSTEM.CARD32;
\end{verbatim}

\begin{verbatim}
VAR
  nullModule: Module; (* Пустое значение типа Module *)
  nullType: Type;     (* Пустое значение типа Type *)
\end{verbatim}

\subsection{Сборка мусора}

\Frame{Collect}{Сборщик мусора}
\begin{verbatim}
PROCEDURE Collect;
\end{verbatim}
Запускает сборку мусора.

\Frame{GetInfo}{Информация об использованной памяти}
\begin{verbatim}
PROCEDURE GetInfo(VAR objects, busymem: CARDINAL);
\end{verbatim}
Возвращает количество аллоцированных объектов 
и общий размер выделенной памяти.

\subsection{Финализация объектов}

Система со сборкой мусора имеет свои специфические черты.
Ее основное отличие от других систем в том, что освобождение
любого системного ресурса должно быть отложено до сборки мусора.
Например, пусть некоторая структура данных содержит 
дескрипторы открытых файлов. Чтобы закрыть файл (т.е. уничтожить
его дескриптор), необходимо знать, что не осталось ссылок на этот файл.
Такую информацию можно получить только при сборке мусора.
Тот же аргумент применим и к другим типам ресурсов.

Немедленным следствием этого является необходимость механизма
{\em финализации}: возможность исполнить какие-то операции 
с объектом после того, как на него не осталось ссылок.

\XDS{} позволяет задать для любого объекта процедуру финализации.

\Frame{Finalizer}{Тип процедуры финализации}
\begin{verbatim}
TYPE Finalizer = PROCEDURE (SYSTEM.ADDRESS);
\end{verbatim}

\Frame{InstallFinalizer}{Установить финализатор объекта}
\begin{verbatim}
PROCEDURE InstallFinalizer(f: Finalizer; obj: SYSTEM.ADDRESS);
\end{verbatim}

Эта процедура объявляет процедуру "f" финализатором объекта "obj".
%???
Процедура "f" вызывается, когда объект становится недоступным.
{\bf Замечание}: финализатор вызывается на стеке
GC (размер стека ограничен).

\Example
\begin{verbatim}
TYPE
  Obj = POINTER TO ObjDesc;
  ObjDesc = RECORD
    file: File; (* file handler *)
  END;

PROCEDURE Final(x: SYSTEM.ADDRESS);
  VAR o: Obj;
BEGIN
  o:=SYSTEM.CAST(Obj,x);
  IF o.file # NIL THEN Close(file) END;
END Final;

PROCEDURE Create(): Obj;
  VAR o: Obj;
BEGIN
  NEW(o);
  o.file:=NIL;
  oberonRTS.InstallFinalizer(Final,o);
  TryOpen(o.file);
END Create;
\end{verbatim}

\subsection{Метаязыковые средства}

Метапрограммные операции позволяют получить тип объекта, создать
объект данного типа, узнать имя типа, найти тип по его имени и~т.д.

\Frame{Search}{Найти Модуль по Имени}
\begin{verbatim}
PROCEDURE Search(name: ARRAY OF CHAR): Module;
\end{verbatim}
По заданному имени модуля выдает модуль или {\tt nullModule}.

\Frame{NameOfModule}{Имя Модуля}
\begin{verbatim}
PROCEDURE NameOfModule(m: Module;
                VAR name: ARRAY OF CHAR);
\end{verbatim}
Возвращает имя модуля.

\Frame{ThisCommand}{Получить Команду по Имени}
\begin{verbatim}
PROCEDURE ThisCommand(m: Module;
                   name: ARRAY OF CHAR;
                     ): Command;
\end{verbatim}
Возвращает команду (процедуру без параметров) с именем {\tt name}
из модуля {\tt m}, или NIL, если такой команды нет.

\Frame{ThisType}{Получить Тип по Имени}
\begin{verbatim}
PROCEDURE ThisType(m: Module;
                name: ARRAY OF CHAR): Type;
\end{verbatim}
Возвращает тип с именем {\tt name}, описанный в модуле
{\tt m}, или {\tt nullType}, если такого типа нет.

\Frame{SizeOf}{Размер Типа}
\begin{verbatim}
PROCEDURE SizeOf(t: Type): INTEGER;
\end{verbatim}
Возвращает размер (в байтах) объекта типа {\tt t}.

\Frame{BaseOf}{Базовый Тип}
\begin{verbatim}
PROCEDURE BaseOf(t: Type; level: INTEGER): Type;
\end{verbatim}
Возвращает базовый тип уровня {\em level} типа {\tt t}.

\Frame{LevelOf}{Уровень Расширения Типа}
\begin{verbatim}
PROCEDURE LevelOf(t: Type): INTEGER;
\end{verbatim}
Возвращает уровень расширения типа.

\Frame{ModuleOf}{Модуль Типа}
\begin{verbatim}
PROCEDURE ModuleOf(t: Type): Module;
\end{verbatim}
Возвращает модуль, в котором описан тип {\tt t}.

\Frame{NameOfType}{Имя Типа}
\begin{verbatim}
PROCEDURE NameOfType(t: Type; VAR name: ARRAY OF CHAR);
\end{verbatim}
Возвращает имя типа  записи.

\Frame{TypeOf}{Тип Объекта}
\begin{verbatim}
PROCEDURE TypeOf(obj: SYSTEM.ADDRESS): Type;
\end{verbatim}
Возвращает тип объекта.

\Frame{NewObj}{Создать Объект}
\begin{verbatim}
PROCEDURE NewObj(type: Type): SYSTEM.ADDRESS;
\end{verbatim}
Создает новый объект типа {\tt t}.

\subsection{Итераторы модулей}

Модуль содержит также итераторы, позволяющие проделывать какое-либо
действие со всеми загруженными модулями, со всеми командами или 
со всеми типами объектов (т.е. с экспортируемыми типами записей).

\Frame{NameIterator}{Тип Итератор}
\begin{verbatim}
TYPE
  NameIterator = PROCEDURE (
                   (*context:*) SYSTEM.ADDRESS,
                   (*name:*) ARRAY OF CHAR
                 ): BOOLEAN;
\end{verbatim}
Процедура типа {\tt NameIterator} вызывается итератором для каждого
итерируемого объекта. Итератор передает ей имя объекта и 
слово, содержащее так называемый {\em контекст}. Это позволяет
передавать процедуре, определенной пользователем, некоторую
контекстную информацию (напр. обработчик файлов). %??? file handler
Процесс итерации прерывается, если итерируемая процедура 
возвращает  FALSE.

\Frame{IterModules}{Итерировать все Модули}
\begin{verbatim}
PROCEDURE IterModules(context: SYSTEM.ADDRESS;
                         iter: NameIterator);
\end{verbatim}
Процедура итерирует все \ot{} модули.

\Frame{IterCommands}{Итерировать Команды}
\begin{verbatim}
PROCEDURE IterCommands(mod: Module;
                   context: SYSTEM.ADDRESS;
                      iter: NameIterator);
\end{verbatim}
Итерирует все команды, реализованные в модуле {\tt mod}.

\Frame{IterTypes}{Итерировать Типы Записей}
\begin{verbatim}
PROCEDURE IterTypes(mod: Module;
                context: SYSTEM.WORD;
                   iter: NameIterator);
\end{verbatim}
Итерирует все типы записей, описанные в модуле {\tt mod}.


% examples
