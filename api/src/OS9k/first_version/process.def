(* process.def  Mar 4  14:57:45  2000 *)
(* Generated by H2D v1.31.0 from process.h. *)
<*+ M2ADDTYPES *>
<*+ M2EXTENSIONS *>
<*+ NOHEADER *> 
<* IF NOT DEFINED(GENTYPEDEF) THEN *> <* NEW GENTYPEDEF+ *> <* END *>

DEFINITION MODULE ["C"] process;

IMPORT types, module, moddir, signal, regs, regppc,
alloc, SYSTEM;
(* H2D:  Required IMPORT clause: 
IMPORT process, types, module, moddir, signal, regs,
  regppc, alloc;
*)

(*  OS-9000 process descriptor definitions  *)

CONST 
  STACKSIZE = 16*1024;   (*  size of system state stack for processes		 *)
  NUMPATHS = 32;   (*  number of paths per process 					 *)
  DEFIOSIZE = 32;   (*  maximum number of paths per process			 *)
  SUBMAX = 16;   (*  number of per process subroutine modules 	 *)
  TRAPMAX = 16;   (*  number of per process trap handlers			 *)
  BRKPTS = 16;   (*  maximum number of break points per process	 *)
  EVENTS = 15;   (*  number of events per event mapping table		 *)
  EV_SLOTS = 2;   (*  number of status slots per event in table	 *)
  EVTBLSIZ = 128;   (*  |event_id|link_cnt| 	 *)
  CHILDREN = 10;   (*  number of children per status block			 *)
  CHILD_SLOTSZ = 3;   (*  number of status slots per child in block	 *)

(*  child status block size:  1 unit = |child ID|status|exit status|			 *)

CONST 
  CHILD_BLKSZ = 128;

(*  children status bit definitions for  *)

CONST 
  ACTIVE_CHILD = 1H;   (*  active child flag in parent's child block	 *)

(*  process memory image definitions  *)
CONST 
  MEMIMGSZ = 256;

(*  Signal flag bits (in P$SigFlg)  *)

CONST 
  B_SIGMASK = 0;   (*  signals are masked when set  *)
  B_WAKEUP = 80H;   (*  wakeup is pending when set  *)

CONST 
  THREAD_ID = 0AFAFAFAFH;   (*  thread block identifier (sync)  *)

(*  definition of flags of the thread block flags variable  *)

CONST 
  TH_DELPB = 1H;   (*  delete parameter block of thread block  *)
  TH_SPOWN = 2H;   (*  flag to make the system process own the thread  *)

(*  Thread Execution Block  *)

TYPE 
  Thread = POINTER TO thread;

  thread = RECORD  
    t_id      : types.u_int32;     (*  reserved 										 *)
    t_proc    : types.process_id;  (*  owner process ID (zero if none) 				 *)
    t_msiz    : types.u_int32;     (*  thread block memory size 						 *)
    t_owner   : types.owner_id;    (*  owner's group/user number 						 *)
    t_next    : Thread;                (*  next thread in doubly linked list 				 *)
    t_prev    : Thread;                (*  previous thread in doubly linked list 			 *)
    t_linkn   : Thread;                (*  next list of associated threads (owner link) 	 *)
    t_linkp   : Thread;                (*  previous list of associated threads (owner link) *)
    t_cycle   : types.u_int32;     (*  wakeup cycle period 							 *)
    t_wktime  : types.u_int32;     (*  wakeup time 									 *)
    t_flags   : types.u_int32;     (*  thread block flags 								 *)
    t_function: types.ProcBYTEu32;           (*  function to execute 							 *)
    t_func_pb : SYSTEM.ADDRESS;        (*  parameter block to pass to function 			 *)
  END;

(* Type 'Thread' was declared here in the source file *)

  Pr_desc = POINTER TO prdsc;

  prdsc = RECORD
    p_sync    : types.u_int32;                           (*  process descriptor sync code						 *)
    p_id      : types.process_id;                        (*  process id										 *)
    p_pid     : types.process_id;                        (*  parent's process id								 *)
    p_owner   : types.owner_id;                          (*  group/user numbers								 *)
    p_rsrv1   : ARRAY [0..4-1] OF types.u_int32;         (*  reserved space									 *)
    p_pmodul  : module.Mh_exec;                          (*  primary module pointer							 *)
    p_pdsize  : types.u_int32;                           (*  size of process descriptor						 *)
    p_prior   : types.u_int16;                           (*  priority											 *)
    p_age     : types.u_int16;                           (*  age												 *)
    p_sched   : types.u_int32;                           (*  process scheduling constant						 *)
    p_state   : types.u_int32;                           (*  process status bit flags							 *)
    p_queueid : types.u_int32;                           (*  current queue id									 *)
    p_preempt : types.u_int32;                           (*  system-state preemption flag, 0 = switchable		 *)
    p_srstat  : types.u_int32;                           (*  process service request capability status		 *)
    p_srmask  : types.u_int32;                           (*  process service request mask						 *)
    p_status  : types.error_code;                        (*  exit (error) status of condemned process			 *)
    p_timbeg  : types.u_int32;                           (*  time when forked in seconds from system ref. date *)
    p_uticks  : types.u_int32;                           (*  user state ticks elapsed							 *)
    p_sticks  : types.u_int32;                           (*  system state tick elapsed						 *)
    p_dlockn  : types.process_id;                        (*  process id of next process in deadlock chain		 *)
    p_queuen  : Pr_desc;                                     (*  general purpose queue next pointer				 *)
    p_queuep  : Pr_desc;                                     (*  general purpose queue previous pointer			 *)
    p_lockqn  : Pr_desc;                                     (*  next process in resource lock queue				 *)
    p_lockqp  : Pr_desc;                                     (*  previous process in resource lock queue			 *)
    p_sp      : regppc.Regs;                             (*  system stack pointer								 *)
    p_usp     : types.Ptru_char;                               (*  user stack pointer								 *)
    p_excpsp  : types.Ptru_char;                               (*  system state exception recovery stack			 *)
    p_excppc  : types.Ptru_int32;                              (*  system state exception recovery pc				 *)
    p_tvalue  : types.Ptru_int32;                              (*  real-time IRQ supporte test value				 *)
    p_taddr   : types.Ptru_int32;                              (*  real-time IRQ support test value address			 *)
    p_rtistate: SYSTEM.ADDRESS;                              (*  pointer to restoration state upon rti trigger	 *)
    p_spuimg  : types.Ptru_char;                               (*  pointer to process' SPU image					 *)
    p_mdir    : moddir.Mod_dir;                          (*  process' current module directory				 *)
    p_altmdir : moddir.Mod_dir;                          (*  process' alternate module directory				 *)
    p_smdir   : moddir.Mod_dir;                          (*  process' current shared module directory 		 *)
    p_sigflg  : types.u_int16;                           (*  signal flag										 *)
    p_siglvl  : types.u_int16;                           (*  signal interrupt level							 *)
    p_sigvec  : types.ProcBYTEu32;                                 (*  signal intercept vector							 *)
    p_sigdat  : types.Ptru_char;                               (*  signal intercept data address					 *)
    p_sigmask : types.u_int32;                           (*  mask to disable signals 2-31						 *)
    p_sigcnt  : types.u_int32;                           (*  number of signals pending						 *)
    p_sigiret : types.u_int32;                           (*  signal intercept recursion counter				 *)
    p_siglst  : types.u_int32;                           (*  last signal the process received					 *)
    p_sigsiz  : types.u_int32;                           (*  maximum number of queued signals for process		 *)
    p_sigque  : types.Ptru_int32;                              (*  pointer to head of signal code queue block		 *)
    p_sigqend : types.Ptru_int32;                              (*  pointer to end of signal code queue block		 *)
    p_sigin   : types.Ptru_int32;                              (*  pointer to next signal "in" slot					 *)
    p_sigout  : types.Ptru_int32;                              (*  pointer to next signal "out" slot				 *)
    p_iopd    : SYSTEM.ADDRESS;                              (*  pointer to associated I/O process descriptor		 *)
    p_rsrv2   : ARRAY [0..4-1] OF types.u_int32;         (*  reserved space									 *)
<*IF NOT DEFINED(_RPTHREAD) THEN *>  
    p_scall   : types.u_int32;                           (*  last user state system call executed				 *)
    p_fcalls  : types.u_int32;                           (*  number of system calls executed					 *)
    p_icalls  : types.u_int32;                           (*  number of I/O calls executed						 *)
    p_data    : types.Ptru_char;                               (*  pointer to process' primary data area			 *)
    p_datasz  : types.u_int32;                           (*  size of primary data area						 *)
    p_frag    : ARRAY [0..2-1] OF alloc.Mem_color;       (*  process memory fragment list						 *)
    p_miblks  : types.Ptru_int32;                              (*  pointer to list of memory image blocks			 *)
    p_memimg  : ARRAY [0..(32*2)-1] OF types.Ptru_int32;       (*  allocated memory block pointers & sizes			 *)
    p_pmiblks : types.Ptru_int32;                              (*  allocated & protectected memory pointers & sizes	 *)
    p_fpusave : SYSTEM.ADDRESS;                              (*  pointer to FPU save area							 *)
    p_chldcnt : types.u_int32;                           (*  count of process' children						 *)
    p_chldrn  : ARRAY [0..((CHILDREN*CHILD_SLOTSZ)+2)-1] OF types.u_int32;(*  child status block			 *)
    p_evcnt   : types.u_int32;                           (*  number of linked events					 *)
    p_evtbl   : ARRAY [0..((EVENTS*EV_SLOTS)+2)-1] OF types.u_int32;(*  event mapping table (linked events)	 *)
    p_thread  : ARRAY [0..2-1] OF Thread;                    (*  doubly linked system thread queue head	 *)
    p_except  : ARRAY [0..regppc.TRAP_TTL-1] OF types.Ptru_int32;(*  program error exception vectors			 *)
    p_exstk   : ARRAY [0..regppc.TRAP_TTL-1] OF types.Ptru_char;(*  program error exception stack frame ptrs  *)
    p_sublib  : ARRAY [0..SUBMAX-1] OF module.Mh_com;    (*  subroutine module pointers				 *)
    p_submem  : ARRAY [0..SUBMAX-1] OF types.Ptru_char;        (*  subroutine library static memory pointers *)
    p_traps   : ARRAY [0..TRAPMAX-1] OF module.Mh_trap;  (*  user's trap vector table					 *)
    p_trpmem  : ARRAY [0..TRAPMAX-1] OF types.Ptru_char;       (*  user's trap static memory block pointers	 *)
    p_trpsiz  : ARRAY [0..TRAPMAX-1] OF types.u_int32;   (*  trap handler static memory sizes			 *)
    p_dbgpar  : Pr_desc;                                     (*  debugging parent process pointer			 *)
    p_dbgmode : types.u_int32;                           (*  debug process execution mode				 *)
    p_dbgins  : types.u_int32;                           (*  debug execution instruction count		 *)
    p_dbgreg  : regppc.Regs;                             (*  debug process register stack frame		 *)
    p_dbgfreg : regppc.Fregs;                            (*  debug process FPU register stack frame	 *)
    p_bpvalue : ARRAY [0..BRKPTS-1] OF types.u_int32;    (*  breakpoint instruction save area			 *)
    p_dbgrsc  : SYSTEM.ADDRESS;                              (*  additional debugging resources (reserved) *)
<*END*>
    p_rsrv3   : ARRAY [0..7-1] OF types.u_int32;         (*  reserved space							 *)
    p_procstk : ARRAY [0..STACKSIZE-1] OF types.u_char;  (*  system state stack for process			 *)
    p_stackend: types.u_char;
  END;

(* Type 'Pr_desc' was declared here in the source file *)

  pr_desc = prdsc;

(*  Process State Flag Bits  *)

CONST 
  FPUPROC = 400H;   (*  xxxx x1xx xxxx xxxx process using FPU  *)
  RTPROC = 200H;   (*  xxxx xx1x xxxx xxxx representative thread proc  *)
  DBGPROC = 100H;   (*  xxxx xxx1 xxxx xxxx process is a debug process  *)
  SYSSTATE = 80H;   (*  xxxx xxxx 1xxx xxxx executing in system state  *)
  TIMSLEEP = 40H;   (*  xxxx xxxx x1xx xxxx process in timed sleep  *)
  TIMOUT = 20H;   (*  xxxx xxxx xx1x xxxx time slice has expired  *)
  IMGCHG = 10H;   (*  xxxx xxxx xxx1 xxxx SPU/MMU protection map has changed  *)
  SIGNAL = 8H;   (*  xxxx xxxx xxxx 1xxx signal pending flag  *)
  TRACEIT = 4H;   (*  xxxx xxxx xxxx x1xx need to trace this process  *)
  CONDEMN = 2H;   (*  xxxx xxxx xxxx xx1x process is condemned  *)
  DEAD = 1H;   (*  xxxx xxxx xxxx xxx1 process has terminated  *)

(*  Process State Flag Bits Numbers  *)

CONST 
  FPUPROCBT = 400H;   (*  xxxx x1xx xxxx xxxx process using FPU 		  *)
  RTPROCBT = 200H;   (*  xxxx xx1x xxxx xxxx representative thread proc  *)
  DBGPROCBT = 100H;   (*  xxxx xxx1 xxxx xxxx process is a debug process  *)
  SYSSTATEBT = 80H;   (*  xxxx xxxx 1xxx xxxx executing in system state   *)
  TIMSLEEPBT = 40H;   (*  xxxx xxxx x1xx xxxx timed sleep 				  *)
  TIMOUTBT = 20H;   (*  xxxx xxxx xx1x xxxx time slice has expired 	  *)
  IMGCHGBT = 10H;   (*  xxxx xxxx xxx1 xxxx SPU/MMU memory map has changed  *)
  TRACEITBT = 4H;   (*  xxxx xxxx xxxx x1xx need to trace this process  *)
  CONDEMNBT = 2H;   (*  xxxx xxxx xxxx xx1x process is condemned 		  *)
  DEADBT = 1H;   (*  xxxx xxxx xxxx xxx1 process has terminated 	  *)

(*  Process Queue ID codes  *)

CONST 
  Q_NONE = ' ';   (*  not in any queue 						 *)
  Q_DEAD = '-';   (*  no queue: dead process 					 *)
  Q_ACTIVE = 'a';   (*  active process queue 					 *)
  Q_DEBUG = 'd';   (*  no queue: inactively debugging 			 *)
  Q_EVENT = 'e';   (*  event queue 								 *)
  Q_SLEEP = 's';   (*  sleep queue 								 *)
  Q_WAIT = 'w';   (*  waiting queue 							 *)
  Q_CURRNT = '*';   (*  no queue: currently running 				 *)
  Q_SUSPEND = 'z';   (*  no queue: state saved and inactive 		 *)
  Q_SEMA = 'p';   (*  process is suspended in semaphore queue   *)
  Q_REMOTE = 'r';   (*  remote processor request wait queue 		 *)

(*  Child Process Status Bits  *)

CONST 
  CS_ACTIVE = 80000000H;   (*  child process is active (has not exited)	 *)
  CS_EXIT = 40000000H;   (*  notify parent of exiting child			 *)

PROCEDURE _os_chain ( arg0: types.u_int32; arg1: types.u_int32;
		      arg2: types.PtrSChar; arg3: SYSTEM.ADDRESS;
		      arg4: types.u_int32; arg5: types.u_int32;
		      arg6: types.u_int32 ): types.error_code;

PROCEDURE _os_chainm ( arg0: types.u_int32; arg1: types.u_int32;
		       arg2: module.Mh_com; arg3: SYSTEM.ADDRESS;
		       arg4: types.u_int32;
		       arg5: types.u_int32 ): types.error_code;

PROCEDURE _os_cpy_ioproc ( arg0: types.process_id; arg1: SYSTEM.ADDRESS;
			   arg2: types.u_int32 ): types.error_code;

PROCEDURE _os_cpymem ( arg0: types.process_id; arg1: SYSTEM.ADDRESS;
                       arg2: SYSTEM.ADDRESS;
		       arg3: types.u_int32 ): types.error_code;

PROCEDURE _os_ddlk ( arg0: types.process_id ): types.error_code;

PROCEDURE _os_exec ( arg0: types.ProcBYTEu32; arg1: types.u_int32;
		     arg2: types.u_int32; arg3: SYSTEM.ADDRESS;
		     arg4: types.PtrPtrSChar; arg5: types.PtrPtrSChar;
		     arg6: types.u_int32;
		     SEQ arg7: SYSTEM.BYTE ): types.error_code;

PROCEDURE _os_exit ( arg0: types.status_code ): types.error_code;

PROCEDURE _os_fork ( arg0: types.u_int32; arg1: types.u_int32;
		     arg2: types.PtrSChar; arg3: SYSTEM.ADDRESS;
		     arg4: types.u_int32; arg5: types.u_int32;
		     arg6: types.Ptru_int32; arg7: types.u_int32;
		     arg8: types.u_int32 ): types.error_code;

PROCEDURE _os_forkm ( arg0: types.u_int32; arg1: types.u_int32;
		      arg2: module.Mh_com; arg3: SYSTEM.ADDRESS;
		      arg4: types.u_int32; arg5: types.u_int32;
		      arg6: types.Ptru_int32;
		      arg7: types.u_int32 ): types.error_code;

PROCEDURE _os_get_prtbl ( arg0: SYSTEM.ADDRESS;
			  arg1: types.Ptru_int32 ): types.error_code;

PROCEDURE _os_gprdsc ( arg0: types.process_id; arg1: SYSTEM.ADDRESS;
		       arg2: types.Ptru_int32 ): types.error_code;

PROCEDURE _os_id ( arg0: types.Ptru_int32; arg1: types.Ptru_int16; arg2: types.Ptru_int16;
		   arg3: types.Ptrint32; arg4: types.Ptru_int16;
		   arg5: types.Ptru_int16 ): types.error_code;

PROCEDURE _os_permit ( arg0: SYSTEM.ADDRESS; arg1: types.u_int32;
		       arg2: types.u_int32;
		       arg3: types.process_id ): types.error_code;

PROCEDURE _os_protect ( arg0: SYSTEM.ADDRESS; arg1: types.u_int32;
			arg2: types.u_int32;
			arg3: types.process_id ): types.error_code;

PROCEDURE _os_setpr ( arg0: types.process_id;
		      arg1: types.u_int32 ): types.error_code;

PROCEDURE _os_setuid ( arg0: types.owner_id ): types.error_code;

PROCEDURE _os_suspend ( arg0: types.process_id ): types.error_code;

PROCEDURE _os_sysdbg ( arg0: SYSTEM.ADDRESS;
		       arg1: SYSTEM.ADDRESS ): types.error_code;

TYPE 
  Ptrpr_desc = POINTER TO pr_desc;

PROCEDURE _os_uacct ( arg0: types.u_int32;
		      arg1: Ptrpr_desc ): types.error_code;

PROCEDURE _os_wait ( arg0: types.Ptru_int32;
		     arg1: types.Ptru_int32 ): types.error_code;

PROCEDURE _os_alltsk ( arg0: Ptrpr_desc ): types.error_code;

TYPE 
  PtrPtrpr_desc = POINTER TO Ptrpr_desc;

PROCEDURE _os_alocproc ( arg0: types.Ptru_int32;
			 arg1: PtrPtrpr_desc ): types.error_code;

PROCEDURE _os_aproc ( arg0: types.process_id ): types.error_code;

PROCEDURE _os_chkmem ( arg0: types.u_int32; arg1: types.u_int32;
                       arg2: SYSTEM.ADDRESS;
		       arg3: Ptrpr_desc ): types.error_code;

PROCEDURE _os_deltsk ( arg0: Ptrpr_desc ): types.error_code;

PROCEDURE _os_findpd ( arg0: types.process_id;
		       arg1: PtrPtrpr_desc ): types.error_code;

PROCEDURE _os_ioexit ( arg0: types.process_id;
		       arg1: types.u_int32 ): types.error_code;

PROCEDURE _os_iofork ( arg0: types.process_id; arg1: types.process_id;
		       arg2: types.u_int32 ): types.error_code;

PROCEDURE _os_nproc (  ): types.error_code;

PROCEDURE _os_rtnprc ( arg0: types.process_id ): types.error_code;

END process.
