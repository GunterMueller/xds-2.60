(* scf.def  Feb 29  11:17:34  2000 *)
(* Generated by H2D v1.31.0 from scf.h. *)
<*+ M2ADDTYPES *>
<*+ M2EXTENSIONS *>
<*+ NOHEADER *> 
<* IF NOT DEFINED(GENTYPEDEF) THEN *> <* NEW GENTYPEDEF+ *> <* END *>

DEFINITION MODULE ["C"] scf;

IMPORT io, types, module, lock, process, SYSTEM;
(* H2D:  Required IMPORT clause: 
IMPORT scf, io, types, module, lock, process;
*)


CONST 
  NUM_IRQS = 8;

TYPE 
  scf_fm_stat = RECORD
    func_count: types.u_int32;
    v_attach  : types.ProcBYTEerr;                          (*  address of Scf's "attach" function  *)
    v_chgdir  : types.ProcBYTEerr;                          (*  address of Scf's "chgdir" function  *)
    v_close   : types.ProcBYTEerr;                          (*  address of Scf's "close" function  *)
    v_create  : types.ProcBYTEerr;                          (*  address of Scf's "create" function  *)
    v_delete  : types.ProcBYTEerr;                          (*  address of Scf's "delete" function  *)
    v_detach  : types.ProcBYTEerr;                          (*  address of Scf's "detach" function  *)
    v_dup     : types.ProcBYTEerr;                          (*  address of Scf's "dup" function  *)
    v_getstat : types.ProcBYTEerr;                          (*  address of Scf's "getstat" function  *)
    v_makdir  : types.ProcBYTEerr;                          (*  address of Scf's "makdir" function  *)
    v_open    : types.ProcBYTEerr;                          (*  address of Scf's "open" function  *)
    v_read    : types.ProcBYTEerr;                          (*  address of Scf's "read" function  *)
    v_readln  : types.ProcBYTEerr;                          (*  address of Scf's "readln" function  *)
    v_seek    : types.ProcBYTEerr;                          (*  address of Scf's "seek" function  *)
    v_setstat : types.ProcBYTEerr;                          (*  address of Scf's "setstat" function  *)
    v_write   : types.ProcBYTEerr;                          (*  address of Scf's "write" function  *)
    v_writeln : types.ProcBYTEerr;                          (*  address of Scf's "writeln" function  *)
    v_edfunc  : ARRAY [0..16-1] OF types.ProcBYTEerr;       (*  Scf's editing function pointer array	 *)
    v_rsrvd   : ARRAY [0..4-1] OF types.u_int16;  (*  reserved space  *)
  END;

  Scf_fm_stat = POINTER TO scf_fm_stat;

  irq_entry = RECORD
    v_vector_offset: types.hardware_vector;  (*  interrupt routine's vector offset (usually 0)  *)
    v_irqentry     : types.ProcBYTEerr;                (*  address of interrupt service routine  *)
  END;

  scf_drvr_stat = RECORD
    v_init     : types.ProcBYTEerr;                          (*  address of driver's "init" function  *)
    v_read     : types.ProcBYTEerr;                          (*  address of driver's "read" function  *)
    v_write    : types.ProcBYTEerr;                          (*  address of driver's "write" function  *)
    v_getstat  : types.ProcBYTEerr;                          (*  address of driver's "get_status" function  *)
    v_setstat  : types.ProcBYTEerr;                          (*  address of driver's "put_status" function  *)
    v_terminate: types.ProcBYTEerr;                          (*  address of driver's "terminate" function  *)
    v_entxirq  : types.ProcBYTEerr;                          (*  address of driver's "entxirq" function  *)
    (*  	i.e. (enable transmitter interrupts)  *)
    v_dev_entry: io.Dev_list;                      (*  device list entry pointer for device  *)
    (*  (initialized by SCF before calling driver)  *)
    v_attached : types.u_int16;                    (*  driver attached flag (maintained by driver)  *)
    v_rsrvd    : ARRAY [0..7-1] OF types.u_int16;  (*  reserved for future user  *)
    v_irqcnt   : types.u_int32;                    (*  number of driver interrupt service routines  *)
    v_irqrtns  : ARRAY [0..8-1] OF irq_entry;          (*  interrupt service routine entries, Note: the  *)
    (*  first entry is assumed to be the input routine  *)
  END;

  Scf_drvr_stat = POINTER TO scf_drvr_stat;

  Scf_lu_stat = POINTER TO scf_lu_stat;

  Scf_path_opts = POINTER TO scf_path_opts;

  scf_lu_opts = RECORD
    v_optsize : types.u_int16;                   (*  options section size  *)
    v_class   : types.u_char;                    (*  device type;	0 = SCF  *)
    v_err     : types.u_char;                    (*  accumulated errors  *)
    v_pause   : types.u_char;                    (*  immediate pause request  *)
    v_line    : types.u_char;                    (*  lines left until end of page  *)
    v_intr    : types.u_char;                    (*  keyboard interrupt character  *)
    v_quit    : types.u_char;                    (*  keyboard quit character  *)
    v_psch    : types.u_char;                    (*  keyboard pause character  *)
    v_xon     : types.u_char;                    (*  x-on character  *)
    v_xoff    : types.u_char;                    (*  x-off character  *)
    v_baud    : types.u_char;                    (*  Baud rate  *)
    v_parity  : types.u_char;                    (*  Parity  *)
    v_stopbits: types.u_char;                    (*  Stop bits  *)
    v_wordsize: types.u_char;                    (*  Word size  *)
    v_rtsstate: types.u_char;                    (*  RTS state: disable = 0; enable = non-zero  *)
    v_dcdstate: types.u_char;                    (*  current state of DCD line  *)
    v_reserved: ARRAY [0..9-1] OF types.u_char;  (*  reserved for future use  *)
  END;

  scf_lu_stat = RECORD
    v_vector   : types.hardware_vector;               (*  irq vector number  *)
    v_irqlevel : types.u_char;                        (*  irq interrupt level  *)
    v_priority : types.u_char;                        (*  irq polling priority  *)
    v_pollin   : types.u_char;                        (*  polled input flag; 1 = polled, 0 = irq driven  *)
    v_pollout  : types.u_char;                        (*  polled output flag; 1 = polled, 0 = irq driven  *)
    v_inhalt   : types.u_char;                        (*  input halted flag(non-zero if XOFF has been sent)  *)
    v_hangup   : types.u_char;                        (*  set non-0 when data carrier is lost  *)
    v_outhalt  : types.u_char;                        (*  output IRQ's disabled when non-Zero  *)
    v_lu_num   : types.u_int16;                       (*  driver accessible copy of logical unit number  *)
    v_wait     : types.u_int16;                       (*  flags whether a process is waiting on input/output  *)
    v_irqmask  : types.u_int32;                       (*  Interrupt mask word  *)
    v_savirq_fm: types.u_int32;                       (*  previous interrupt mask word	(SCF use only)  *)
    v_savirq_dv: types.u_int32;                       (*  previous interrupt mask word	(driver use only)  *)
    v_savirq_ll: types.u_int32;                       (*  previous interrupt mask word	(low level use only)  *)
    v_wake     : types.process_id;                    (*  id of process to wake up (process waiting on I/O)  *)
    v_busy     : types.process_id;                    (*  id of process currently using device  *)
    v_lproc    : types.process_id;                    (*  number of the last process to use this unit  *)
    v_sigproc  : ARRAY [0..3-1] OF types.process_id;  (*  process to signal on SS_SSIG request  *)
    (*  signal code  *)
(*  associated (system) path number  *)
    v_dcdoff   : ARRAY [0..3-1] OF types.process_id;  (*  process to signal on loss of DCD  *)
    (*  signal process  *)
(*  associated (system) path number  *)
    v_dcdon    : ARRAY [0..3-1] OF types.process_id;  (*  process to signal on loss of DCD  *)
    (*  signal code  *)
(*  associated (system) path number  *)
    v_outdev   : Scf_lu_stat;                             (*  output device's static storage pointer  *)
    v_pdbufsize: types.u_int32;                       (*  SCF's path buffer size for this device  *)
    v_maxbuff  : types.u_int32;                       (*  Send XOFF when buffer is this full  *)
    v_insize   : types.u_int32;                       (*  size of input buffer  *)
    v_incount  : types.u_int32;                       (*  number of bytes in input buffer  *)
    v_inbufad  : types.Ptru_char;                           (*  input buffer address  *)
    v_infill   : types.Ptru_char;                           (*  input buffer next-in pointer  *)
    v_inempty  : types.Ptru_char;                           (*  input buffer next-out pointer  *)
    v_inend    : types.Ptru_char;                           (*  input buffer end of buffer pointer  *)
    v_outsize  : types.u_int32;                       (*  size of output buffer  *)
    v_outcount : types.u_int32;                       (*  number of bytes in output buffer  *)
    v_outbufad : types.Ptru_char;                           (*  output buffer address  *)
    v_outfill  : types.Ptru_char;                           (*  output buffer next-in pointer  *)
    v_outempty : types.Ptru_char;                           (*  output buffer next-out pointer  *)
    v_outend   : types.Ptru_char;                           (*  output buffer end of buffer pointer  *)
    v_lockid   : lock.lock_id;                        (*  I/O lock I.D. number  *)
    v_use_cnt  : types.u_int32;                       (*  logical unit user counter  *)
    v_resrvd   : ARRAY [0..5-1] OF types.u_int32;     (*  reserved space  *)
    v_pdopt    : Scf_path_opts;                           (*  pointer to path descriptor options section  *)
    v_opt      : scf_lu_opts;                             (*  logical unit options section  *)
    (*  defined in the "scxxxx.h" for a specific driver)  *)
  END;

(* Type 'Scf_lu_stat' was declared here in the source file *)

(* Type 'scf_lu_opts' was declared here in the source file *)

  Scf_lu_opts = POINTER TO scf_lu_opts;

  inmap_entry = RECORD
    type     : types.u_int16;  (*  character mapping type  *)
    func_code: types.u_int16;  (*  scf editing function code  *)
    size     : types.u_int32;  (*  size of associated string  *)
    string   : SYSTEM.ADDRESS;     (*  pointer to associated string  *)
  END;

  scf_path_opts = RECORD
    pd_optsize : types.u_int16;                   (*  path options table size  *)
    pd_extra   : types.u_int16;                   (*  maintain long allignment  *)
    pd_inmap   : ARRAY [0..32-1] OF inmap_entry;      (*  Input control character mapping table  *)
    pd_eorch   : types.u_char;                    (*  end of record character (read only)  *)
    pd_eofch   : types.u_char;                    (*  end of file character  *)
    pd_tabch   : types.u_char;                    (*  Tab character (0 = none)  *)
    pd_bellch  : types.u_char;                    (*  bell (line overflow)  *)
    pd_bspch   : types.u_char;                    (*  backspace echo character  *)
    (*  Input line editing mode control flags  *)
    pd_case    : types.u_char;                    (*                case				0 = both   *)
                                                      (* 											1 = upper case only    *)
    pd_backsp  : types.u_char;                    (*                  backspace		0 = backspace    *)
                                                      (* 											1 = backspace, space, backspace   *)
    pd_delete  : types.u_char;                    (*                  delete			0 = carriage return, line feed  *)
                                                      (* 											1 = backspace over line                        *)
    pd_echo    : types.u_char;                    (*  echo				0 = no echo	 *)
    pd_alf     : types.u_char;                    (*  auto-linefeed	0 = no auto line feed  *)
    pd_pause   : types.u_char;                    (*  pause			0 = no end of page pause  *)
    pd_insm    : types.u_char;                    (*                insert mode		0 = type over  *)
                                                      (* 											1 = insert at cursor            *)
    (*  Additional input editing variables  *)
    pd_nulls   : types.u_char;                    (*  end of line null count  *)
    pd_page    : types.u_char;                    (*  lines per page  *)
    pd_tabsiz  : types.u_char;                    (*  tab field size  *)
    pd_err     : types.u_char;                    (*  most recent I/O error status  *)
    pd_rsvd    : ARRAY [0..2-1] OF types.u_char;  (*  reserved  *)
    pd_col     : types.u_int32;                   (*  current column number  *)
    pd_time    : types.u_int32;                   (*  time out value for unblocked reads  *)
    pd_deventry: io.Dev_list;                     (*  Device table address (copy)  *)
  END;

  scf_path_desc = RECORD
    pd_common  : io.pathcom;                       (*  common path descriptor structure  *)
    pd_outdev  : io.Dev_list;                      (*  device tbl pointer for echo device  *)
    pd_ubuf    : types.Ptru_char;                        (*  user buffer base address  *)
    pd_pbuf    : types.Ptru_char;                        (*  path buffer base address  *)
    pd_pbufpos : types.Ptru_char;                        (*  current path buffer position  *)
    pd_endobuf : types.u_int32;                    (*  end of buffer position  *)
    pd_curpos  : types.u_int32;                    (*  cursor position counter  *)
    pd_reqcnt  : types.u_int32;                    (*  number of bytes requested by the caller  *)
    pd_evl     : types.u_int32;                    (*  readln end of visible line counter  *)
    pd_echoflag: types.u_char;                     (*  flags whether echoing output is ok for this device  *)
    pd_lost    : types.u_char;                     (*  non-zero if path has become dead  *)
    (*  (ie: data-carrier-detect lost)  *)
    pd_reserved: ARRAY [0..7-1] OF types.u_int16;  (*  reserved	space  *)
    pd_opt     : scf_path_opts;                        (*  SCF path descriptor options  *)
  END;

  Scf_path_desc = POINTER TO scf_path_desc;

(*  SCF file manager static storage.	 *)
(*  SCF driver interrupt service routine entry table.  *)

  Irq_entry = POINTER TO irq_entry;

(*  SCF driver static storage.  *)
(*  SCF logical unit static storage options section  *)

(*  SCF unit static storage  *)
(*  Path Descriptor options input mapping table entry structure  *)

  Inmap_entry = POINTER TO inmap_entry;

(*  SCF path descriptor options structure  *)
(*  SCF complete path descriptor structure  *)
(*  SCF Device descriptor module data area  *)

  scf_desc = RECORD
    dd_descom  : io.dd_com;                        (*  common device descriptor variables  *)
    dd_outdev  : types.u_int32;                    (*  secondary output device name offset  *)
    dd_rsvd_scf: ARRAY [0..2-1] OF types.u_int16;  (*  reserved space  *)
  END;

  Scf_desc = POINTER TO scf_desc;

(*  scf_lu_opts->v_err: error bit assignments.  *)

CONST 
  SOVERRUN = 1H;
  DCD_LOST = 2H;
  NOT_CTS = 4H;

(*  bit 3 not used	 *)

CONST 
  HOVERRUN = 10H;
  PARITYERR = 20H;
  FRAMING = 40H;
  BREAKERR = 80H;

(*  scf_lu_stat->v_wait values  *)

CONST 
  WT_INPUT = 1;   (*  process waiting on input flag  *)
  WT_OUTPUT = 2;   (*  process wainting on output flag  *)

(*  scf_lu_stat->v_outhalt bit definitions (output halted flags)  *)

CONST 
  OH_XOFF = 1H;   (*  V_XOFF received; awaiting V_XON  *)
  OH_EMPTY = 2H;   (*  output buffer is empty  *)
  OH_IRQON = 80H;   (*  transmitter IRQ is turned on  *)

(*  scf_lu_stat->v_inhalt bit definitions  *)

CONST 
  FLAGBIT = 80H;   (*  flags input halted  *)

(*  scf_lu_stat->v_pollin & scf_lu_stat->v_pollout values  *)

CONST 
  IRQDRIVEN = 0;   (*  unit's I/O is interrupt driven  *)
  POLLED = 1;   (*  unit's I/O is polled  *)

CONST 
  MINBUFF = 10;   (*  minimum buffer size  *)
  LOWCOUNT = 10;   (*  output buffer low count  *)
  CUSOR_POS = 0;
  VISIBLE_LINE = 1;
  UNINITIALIZED = 0;

(*  SCF device baud rate codes (used with lu_options.v_baud)  *)

CONST 
  HARDWIRED = 0H;   (*  baud rate generator is hardware selected	 *)
  BAUD50 = 1H;   (*  baud rate = 50  *)
  BAUD75 = 2H;   (*  baud rate = 75  *)
  BAUD110 = 3H;   (*  baud rate = 110  *)
  BAUD134_5 = 4H;   (*  baud rate = 134.5  *)
  BAUD150 = 5H;   (*  baud rate = 150  *)
  BAUD300 = 6H;   (*  baud rate = 300  *)
  BAUD600 = 7H;   (*  baud rate = 600  *)
  BAUD1200 = 8H;   (*  baud rate = 1200  *)
  BAUD1800 = 9H;   (*  baud rate = 1800  *)
  BAUD2000 = 0AH;   (*  baud rate = 2000  *)
  BAUD2400 = 0BH;   (*  baud rate = 2400  *)
  BAUD3600 = 0CH;   (*  baud rate = 3600  *)
  BAUD4800 = 0DH;   (*  baud rate = 4800  *)
  BAUD7200 = 0EH;   (*  baud rate = 7200  *)
  BAUD9600 = 0FH;   (*  baud rate = 9600  *)
  BAUD19200 = 10H;   (*  baud rate = 19200  *)
  BAUD31250 = 11H;   (*  baud rate = 31250 (MIDI)  *)
  BAUDMIDI = 11H;   (*  baud rate = 31250 (MIDI)  *)
  BAUD38400 = 12H;   (*  baud rate = 38400  *)
  BAUD56000 = 13H;   (*  baud rate = 56000  *)
  BAUD57600 = 14H;   (*  baud rate = 57600  *)
  BAUD64000 = 15H;   (*  baud rate = 64000  *)
  BAUD115200 = 16H;   (*  baud rate = 115200  *)

(*  Baud rate codes 0x17 - 0x7F are undefined and reserved  *)
(*  Baud rate codes 0x80 - 0xFE may be user defined  *)

CONST 
  EXTERNAL = 0FFH;   (*  baud rate is externally produced  *)


(*   #define SCFBTAB		"\                                                      *)
(* \x00\x00\x00\x4B\x00\x6E\x00\x87\x00\x96\x01\x2C\x02\x58\x04\xB0\x07\x08\  *)
(* \x07\xD0\x09\x60\x0E\x10\x12\xC0\x1C\x20\x25\x80\x4B\x00\x7A\x12\x96\x00"  *)
(*                                                                            *)
(*  SCF device parity codes (used with lu_options.v_parity)  *)

CONST 
  SCFBTAB  = ""+0C+0C+0C+113C+0C+156C+0C+207C+0C+226C+01C+54C+02C+130C+04C+260C+07C+10C+
             07C+320C+11C+140C+16C+20C+22C+300C+34C+40C+45C+200C+113C+0C+172C+22C+226C+0C;  
  NOPARITY = 0;
  ODDPARITY = 1;
  EVENPARITY = 2;
  MARKPARITY = 3;
  SPACEPARITY = 4;

(*  SCF device stop bits codes (used with lu_options.v_stopbits)  *)

CONST 
  ONESTOP = 0;
  ONE_5STOP = 1;
  TWOSTOP = 2;

(*  SCF device wordsize codes (used with lu_options.v_wordsize)  *)

CONST 
  WORDSIZE5 = 5;
  WORDSIZE6 = 6;
  WORDSIZE7 = 7;
  WORDSIZE8 = 8;

(*  SCF "ready to send" (RTS) state flag (used with lu_options.v_rtsstate)  *)

CONST 
  RTSDISABLED = 0;
  RTSENABLED = 1;

(*  ASCII control & special character codes  *)

CONST 
  C_NULL = 0H;
  CTRL_A = 1H;
  CTRL_B = 2H;
  CTRL_C = 3H;
  CTRL_D = 4H;
  CTRL_E = 5H;
  CTRL_F = 6H;
  CTRL_G = 7H;
  CTRL_H = 8H;
  CTRL_I = 9H;
  CTRL_J = 0AH;
  CTRL_K = 0BH;
  CTRL_L = 0CH;
  CTRL_M = 0DH;
  CTRL_N = 0EH;
  CTRL_O = 0FH;
  CTRL_P = 10H;
  CTRL_Q = 11H;
  CTRL_R = 12H;
  CTRL_S = 13H;
  CTRL_T = 14H;
  CTRL_U = 15H;
  CTRL_V = 16H;
  CTRL_W = 17H;
  CTRL_X = 18H;
  C_DELLINE = CTRL_X;
  CTRL_Y = 19H;
  CTRL_Z = 1AH;
  C_SPACE = 20H;
  C_COMMA = 2CH;
  C_PERIOD = 2EH;
  C_SLASH = 2FH;

(*  SCF/OS-9 compatible "standard" character codes  *)

CONST 
  C_REPEAT = 1H;
  C_INTR = 3H;
  C_REPRINT = 4H;
  C_QUIT = 5H;
  C_BELL = 7H;
  C_BACKSPACE = 8H;
  C_TAB = 9H;
  C_LINEFEED = 0AH;
  C_FORMFEED = 0CH;
  C_CR = 0DH;
  C_XOFF = 13H;
  C_XON = 11H;
  C_PAUSE = 17H;
  C_EOF = 1BH;

(*  Input mapping type codes	 *)

CONST 
  IGNORE = 0;
  PASSTHRU = 1;
  EDFUNCTION = 2;

(*  Other constants  *)

CONST 
  NOEDFUNCS = 16;
  NOCTRLKEYS = 32;

(*  SCF editing function mapping codes  *)

CONST 
  MOVLEFT = 0H;   (*  move cursor to the left (formerly pd_bsp)  *)
  MOVRIGHT = 1H;   (*  move cursor to the right  *)
  MOVBEG = 2H;   (*  move cursor to the beginning of the line  *)
  MOVEND = 3H;   (*  move cursor to the end of the line  *)
  REPRINT = 4H;   (*  reprint the current line	to cursor position  *)
  TRUNCATE = 5H;   (*  truncate the line at the cursor position  *)
  DELCHRL = 6H;   (*  delete character to the left  *)
  DELCHRU = 7H;   (*  delete character under the cursor  *)
  DELWRDL = 8H;   (*  delete word to the left  *)
  DELWRDR = 9H;   (*  delete word to the right  *)
  DELINE = 0AH;   (*  delete the entire line  *)
  UNDEF1 = 0BH;   (*  undefined (reserved)  *)
  MODETOGL = 0CH;   (*  input mode toggle (type over vs. insert)  *)
  UNDEF2 = 0DH;   (*  undefined (reserved)  *)
  ENDOREC = 0EH;   (*  end of record (read only)  *)
  ENDOFILE = 0FH;   (*  end of file  *)
  JAMSIZE = 35;

(* #define JAMMER		"\\x62\x1b\x59\x74\x3b\x01\x17\x59\x68\x27\\x09\x00\x0b\x0c\x0f\x42\x0c\x64\x08\x60\\x0c\x72\x15\x67\x41\x0f\x0a\x44\x4f\x1b\\x1c\x0d\x17\x01\x7e"; *)
  JAMMER = ""+142C+33C+131C+164C+73C+1C+27C+131C+150C+47C+11C+0C+13C+14C+17C+102C+14C+144C+10C+140C+14C+162C+25C+147C+101C+17C+12C+104C+117C+33C+34C+15C+27C+1C+176C;
PROCEDURE _os_ss_dcoff ( arg0: types.path_id;
			 arg1: types.signal_code ): types.error_code;

PROCEDURE _os_ss_dcon ( arg0: types.path_id;
			arg1: types.signal_code ): types.error_code;

PROCEDURE _os_ss_dsrts ( arg0: types.path_id ): types.error_code;

PROCEDURE _os_ss_enrts ( arg0: types.path_id ): types.error_code;

PROCEDURE _os_ss_fillbuff ( arg0: types.path_id; arg1: types.PtrSChar;
			    arg2: types.u_int32 ): types.error_code;

(*  Mouse Support  *)
(*  kbd_bios  *)

PROCEDURE _os_ss_kbd_led ( path: types.path_id; scroll: types.u_char;
			   num: types.u_char;
			   caps: types.u_char ): types.error_code;

PROCEDURE _os_ss_scan_read ( path: types.path_id; ascii: types.Ptru_char;
			     scan: types.Ptru_char ): types.error_code;

PROCEDURE _os_ss_scan_stuff ( path: types.path_id; ascii: types.u_char;
			      scan: types.u_char ): types.error_code;

PROCEDURE _os_ss_scan_rate ( path: types.path_id; rate: types.u_char;
			     delay: types.u_char ): types.error_code;

PROCEDURE _os_ss_scan_mode ( path: types.path_id;
			     action: types.u_int32 ): types.error_code;

PROCEDURE _os_ss_scan_eread ( path: types.path_id; ascii: types.Ptru_char;
			      scan: types.Ptru_char ): types.error_code;

(*  mouse_res  *)

PROCEDURE _os_ss_mouse_res ( path: types.path_id;
			     res: types.u_char ): types.error_code;

(*  mouse_sample  *)

PROCEDURE _os_ss_mouse_sample ( path: types.path_id;
				sample: types.u_char ): types.error_code;

(*  mouse_scale  *)

PROCEDURE _os_ss_mouse_scale ( path: types.path_id;
			       scale: types.u_char ): types.error_code;

END scf.
