(* os9sbf.def  Feb 29  11:10:12  2000 *)
(* Generated by H2D v1.31.0 from os9sbf.h. *)
<*+ M2ADDTYPES *>
<*+ M2EXTENSIONS *>
<*+ NOHEADER *> 
<* IF NOT DEFINED(GENTYPEDEF) THEN *> <* NEW GENTYPEDEF+ *> <* END *>

DEFINITION MODULE ["C"] os9sbf;

IMPORT os9types, os9io, os9module, os9lock, os9process, os9srvcb, os9moddir,
os9fork, os9rbf, os9time, os9dexec, os9regs, os9regppc, os9alloc,
os9settrap, os9semaphore, SYSTEM;
(* H2D:  Required IMPORT clause: 
IMPORT os9sbf, os9types, os9io, os9module, os9lock, os9process, os9srvcb,
  os9moddir, os9fork, os9rbf, os9time, os9dexec, os9regs, os9regppc,
  os9alloc, os9settrap, os9semaphore;
*)

(*  * necessary pre-requisite defs files  *)
(*  * conditionally include necessary definitions  *)
(*  * constant definitions  *)

CONST 
  DFLG_READFLAG = 1;   (*  read mode flag  *)
  DFLG_WRITEFLAG = 2;   (*  write mode flag  *)
  DFLG_DRIVEBUSY = 4;   (*  driver servicing this drive  *)
  DFLG_EOFFLAG = 8;   (*  drive at EOF flag  *)

(*  * buffer flag definitions  *)

CONST 
  BFLG_BUFERR = 1;   (*  error flag  *)
  BFLG_BUFFULL = 2;   (*  buffer full  *)

(*  * device option flag definitions  *)

CONST 
  DEV_REWIND_FLG = 1;   (*  rewind tape on close  *)
  DEV_ERASE_FLG = 2;   (*  erase to end after writing  *)
  DEV_OFFLINE_FLG = 4;   (*  take drive off line on close  *)
  DEV_SKIPBACK_FLG = 8;   (*  device can skip backwards  *)

(*  * number of entry points into sbf file manager  *)

CONST 
  SBF_ENTRY_POINTS = 16;

(*  * SCSI Options bit defintions - these are applicable to SCSI based hardware  *)
(*  * only.                                                                      *)
(*                           *)
(*  * SBF buffer structure   *)

TYPE 
  Sbf_buf = POINTER TO sbf_buf;

  sbf_path_opts = RECORD
    pd_numblk : os9types.u_int32;  (*  currently unused					 *)
    pd_blksiz : os9types.u_int32;  (*  size of blocks allocated			 *)
    pd_prior  : os9types.u_int16;  (*  currently unused					 *)
    pd_flags  : os9types.u_int16;  (*  SBF/driver capability flags		 *)
    pd_dmamode: os9types.u_int16;  (*  DMA type/usage					 *)
    pd_scsi_id: os9types.u_char;   (*  SCSI controller ID				 *)
    pd_scsilun: os9types.u_char;   (*  SCSI controller drive LUN		 *)
  END;

  sbf_path_desc = RECORD
    pd_io  : os9io.pd_com;      (*  common ioman section  *)
    pd_bcnt: os9types.u_int32;  (*  remaining buffer count  *)
    pd_buf : os9types.Ptru_char;      (*  the current buffer pointer  *)
    pd_bptr: Sbf_buf;            (*  current buffer pointer  *)
    pd_opts: sbf_path_opts;      (*  the option section  *)
  END;

  Sbf_path_desc = POINTER TO sbf_path_desc;

  Ptrsbf_buf = POINTER TO sbf_buf;

  sbf_buf = RECORD
    bh_path  : Sbf_path_desc;         (*  path associated with this buff  *)
    bh_next  : Ptrsbf_buf;        (*  next buffer in list  *)
    bh_siz   : os9types.u_int32;     (*  size of the buffer  *)
    bh_bcnt  : os9types.u_int32;     (*  number of bytes in buffer  *)
    bh_flag  : os9types.u_int16;     (*  the buffer flags  *)
    bh_unused: os9types.u_int16;     (*  unused word  *)
    bh_err   : os9types.error_code;  (*  the error code  *)
    bh_buff  : os9types.Ptru_char;         (*  buffer pointer  *)
  END;

(* Type 'Sbf_buf' was declared here in the source file *)
(*  *	SBF logical unit static storage.  *)

  sbf_lu_stat = RECORD
    sbf_vector      : os9types.u_char;                     (*  the irq vector  *)
    sbf_irqlevel    : os9types.u_char;                     (*  the irq level  *)
    sbf_priority    : os9types.u_char;                     (*  the irq priority  *)
    sbf_unused      : os9types.u_char;                     (*  unused byte  *)
    sbf_dflg        : os9types.u_int16;                    (*  drive flag  *)
    sbf_nbuf        : os9types.u_int16;                    (*  currently unused  *)
    sbf_ibh         : os9types.u_int32;                    (*  currently unused  *)
    sbf_ibt         : os9types.u_int32;                    (*  currently unused  *)
    sbf_obh         : os9types.u_int32;                    (*  currently unused  *)
    sbf_obt         : os9types.u_int32;                    (*  currently unused  *)
    sbf_wait        : os9types.u_int32;                    (*  currently unused  *)
    sbf_serr        : os9types.u_int32;                    (*  number of recoverable errors  *)
    sbf_herr        : os9types.u_int32;                    (*  number of non-recoverable errors  *)
    sbf_crnt_blk    : os9types.u_int32;                    (*  current block position  *)
    sbf_drv_rsrc_id : os9types.u_int32;                    (*  resource id for the drive  *)
    sbf_list_rsrc_id: os9types.u_int32;                    (*  buffer list resource id  *)
    sbf_users       : os9types.u_int32;                    (*  number of users on this device  *)
    sbf_rsv3        : ARRAY [0..4-1] OF os9types.u_int32;  (*  5 unused long words  *)
    sbf_proc_id     : os9types.process_id;                 (*  driver process id  *)
  END;

  Sbf_lu_stat = POINTER TO sbf_lu_stat;

(*  * sbf path descriptor options  *)

  Sbf_path_opts = POINTER TO sbf_path_opts;

(*  *	Sequential block file manager PD definitions  *)

(* Type 'Sbf_path_desc' was declared here in the source file *)

(*  * sbf device descriptor module structure definitions  *)

  sbf_desc = RECORD
    dd_descom : os9io.dd_com;  (*  common header info  *)
    dd_pathopt: sbf_path_opts;  (*  the path options  *)
  END;

  Sbf_desc = POINTER TO sbf_desc;

(*  * file manager static storage definitions  *)

  sbf_fm_stat = RECORD
    count: os9types.u_int32;                             (*  number of entries in table  *)
    func : ARRAY [0..SBF_ENTRY_POINTS-1] OF os9types.ProcBYTEerr;  (*  the dispatch table  *)
  END;

  Sbf_fm_stat = POINTER TO sbf_fm_stat;

(*  * device driver static storage definitions  *)

  sbf_drvr_stat = RECORD
    funcs         : os9types.u_int32;     (*  number of functions  *)
    v_init        : os9types.ProcBYTEerr;           (*  address of driver init routine  *)
    v_read        : os9types.ProcBYTEerr;           (*  address of driver read routine  *)
    v_write       : os9types.ProcBYTEerr;           (*  address of driver write routine  *)
    v_getstat     : os9types.ProcBYTEerr;           (*  address of driver getstat routine  *)
    v_setstat     : os9types.ProcBYTEerr;           (*  address of driver setstat routine  *)
    v_term        : os9types.ProcBYTEerr;           (*  address of device terminate routine  *)
    v_drvr_rsrc_id: os9lock.lock_id;      (*  the driver resource id  *)
    v_busy        : os9types.process_id;  (*  process using the device  *)
    v_wake        : os9types.process_id;  (*  for use by the driver  *)
  END;

  Sbf_drvr_stat = POINTER TO sbf_drvr_stat;

PROCEDURE _os_ss_erase ( arg0: os9types.path_id;
			 arg1: os9types.u_int32 ): os9types.error_code;

PROCEDURE _os_ss_reten ( arg0: os9types.path_id ): os9types.error_code;

PROCEDURE _os_ss_rfm ( arg0: os9types.path_id;
		       arg1: os9types.int32 ): os9types.error_code;

PROCEDURE _os_ss_skip ( arg0: os9types.path_id;
			arg1: os9types.int32 ): os9types.error_code;

PROCEDURE _os_ss_skipend ( arg0: os9types.path_id ): os9types.error_code;

PROCEDURE _os_ss_wfm ( arg0: os9types.path_id;
		       arg1: os9types.u_int32 ): os9types.error_code;

END os9sbf.
