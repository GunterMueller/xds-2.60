(* dexec.def  Feb 29  11:12:33  2000 *)
(* Generated by H2D v1.31.0 from dexec.h. *)
<*+ M2ADDTYPES *>
<*+ M2EXTENSIONS *>
<*+ NOHEADER *> 
<* IF NOT DEFINED(GENTYPEDEF) THEN *> <* NEW GENTYPEDEF+ *> <* END *>

DEFINITION MODULE ["C"] dexec;

IMPORT types, regs, regppc, module, SYSTEM;
(* H2D:  Required IMPORT clause: 
IMPORT dexec, types, regs, regppc, module;
*)

(* H2D: Enumeration: dexec_mode *)

CONST 
  DBG_M_INACTV = 0;   (*  inactive mode (used by kernel)  *)
  DBG_M_HARD = 1;   (*  hard break points / full speed execution	 *)
  DBG_M_SOFT = 2;   (*  soft break points / continuous execution  *)
  DBG_M_COUNT = 3;   (*  execute count instructions				 *)
  DBG_M_CONTROL = 4;   (*  execute until change of control (future)	 *)

TYPE 
  dexec_mode = SYSTEM.int;
(* H2D: End of enumeration: dexec_mode *)

(*  dexec() return status  *)
(* H2D: Enumeration: dexec_status *)


CONST 
  DBG_S_FINISH = 0;   (*  command finished successfully			 *)
  DBG_S_BRKPNT = 1;   (*  process hit break point					 *)
  DBG_S_EXCEPT = 2;   (*  execption occurred during execution 		 *)
  DBG_S_CHILDSIG = 3;   (*  process received signal (no intercept)	 *)
  DBG_S_PARENTSIG = 4;   (*  debugger received signal					 *)
  DBG_S_CHAIN = 5;   (*  process has made an F$Chain call			 *)
  DBG_S_EXIT = 6;   (*  process has made an F$Exit call			 *)
  DBG_S_CONTROL = 7;   (*  process executed a jmp or bra (future)	 *)
  DBG_S_WATCH = 8;   (*  process hit watch point (future)			 *)
  DBG_S_FORK = 9;   (*  process has made an F$Fork call			 *)

TYPE 
  dexec_status = SYSTEM.int;
(* H2D: End of enumeration: dexec_status *)

  Ptrdexec_status = POINTER TO dexec_status;

PROCEDURE _os_dexec ( arg0: types.process_id; arg1: dexec_mode;
		      arg2: SYSTEM.ADDRESS; arg3: types.Ptru_int32;
		      arg4: types.u_int32; arg5: types.PtrPtrVoid;
		      arg6: types.Ptru_int32; arg7: Ptrdexec_status;
		      arg8: types.Ptru_int32; arg9: types.PtrPtrVoid;
		      arg10: types.Ptru_int32 ): types.error_code;

PROCEDURE _os_dexit ( arg0: types.process_id ): types.error_code;

(*TYPE 
  Ptrfregs = regppc.Fregs;*)

PROCEDURE _os_dfork ( arg0: types.u_int32; arg1: types.u_int32;
		      arg2: types.PtrSChar; arg3: SYSTEM.ADDRESS;
		      arg4: types.u_int32; arg5: types.u_int32;
		      arg6: types.Ptru_int32; arg7: types.u_int32;
		      arg8: types.PtrSChar; arg9: regppc.Fregs ): types.error_code;

PROCEDURE _os_dforkm ( arg0: types.u_int32; arg1: types.u_int32;
		       arg2: module.Mh_com; arg3: SYSTEM.ADDRESS;
		       arg4: types.u_int32; arg5: types.u_int32;
		       arg6: types.Ptru_int32; arg7: types.PtrSChar;
		       arg8: regppc.Fregs ): types.error_code;

END dexec.
