(* rbf.def  Feb 29  10:22:54  2000 *)
(* Generated by H2D v1.31.0 from rbf.h. *)
<*+ M2ADDTYPES *>
<*+ M2EXTENSIONS *>
<*+ NOHEADER *> 
<* IF NOT DEFINED(GENTYPEDEF) THEN *> <* NEW GENTYPEDEF+ *> <* END *>

DEFINITION MODULE ["C"] rbf;

IMPORT types, io, module, lock, process, time, SYSTEM;
(* H2D:  Required IMPORT clause: 
IMPORT rbf, types, io, module, lock, process, time;
*)

CONST 
  IDB_SYNC = 0ADB0B0ADH;   (*  the sync field  *)

(*  *	ID block rid_flags bit definitions  *)

CONST 
  RID_FLAG_EPOCH = 1;   (*  time epoch, 0 = 1980, 1 = 1970  *)

(*  * big/little endian flags  *)


CONST 
  BIG_END = 42H;   (*  big endian  *)
  LITTLE_END = 4CH;   (*  little endian  *)

(*  * length that indicates entire file should be locked  *)

CONST 
  LOCK_ENTIRE = -1;   (*  lock the entire file  *)

(*  * rbf path name equates   *)

CONST 
  MAXNAME = 43;   (*  size of name  *)
  DIRENTSIZE = 64;   (*  size of directory entry  *)

(*  * buffer state flags  *)

CONST 
  BK_BUFMOD = 1;   (*  buffer modified  *)
  BK_BINBUF = 2;   (*  block in buffer  *)
  BK_FDBUF = 4;   (*  file descriptor in buffer  *)
  BK_BUFBUSY = 16;   (*  buffer is busy; may not be swapped  *)
  BK_INDRIVER = 32;   (*  in device driver  *)
  BK_IODIRECT = 64;   (*  I/O to caller's buffer; don't swap  *)
  BK_DELETED = 128;   (*  file is being deleted  *)

(*  * mode state flags  *)

CONST 
  MODE_BLKMODE = 1;   (*  block mode for @  *)
  MODE_DIRIO = 2;   (*  i/o being done for directories  *)

(*  * record locking definitions  *)

CONST 
  B_rcdlock = 1;   (*  record from lolock to hilock is locked  *)
  B_filelock = 2;   (*  entire file is locked  *)
  B_eoflock = 4;   (*  end of file is locked  *)
  B_locksleep = 128;   (*  sleeping waiting for record  *)

(*  * pd_useflags definitions  *)

CONST 
  USEF_DIRTY = 1H;   (*  file is written to, treat like normal  *)

(*  * file descriptor sync code   *)

CONST 
  FD_SYNC = 0FDB0B0FDH;   (*  low nibble is fmt rev  *)

(*  *  definitions for fd type  *)


CONST 
  FD_SMALLFILE = 10000H;   (*  small file (data fits in FD)  *)
  FD_DIRECTORY = 8000H;   (*  directory file  *)
  FD_EXCLUSIVE = 4000H;   (*  exclusize access flag  *)
  FD_SYMLINK = 2000H;   (*  symbolic link file  *)

(*  * permission word definitions  *)


CONST 
  PERM_WORLD_EXEC = 400H;   (*  world execute permission  *)
  PERM_WORLD_SRCH = 400H;   (*  world search permission  *)
  PERM_WORLD_WRITE = 200H;   (*  world write permission  *)
  PERM_WORLD_READ = 100H;   (*  world read permission  *)
  PERM_WORLD_MASK = 0F00H;   (*  world mask permission  *)
  PERM_GROUP_EXEC = 40H;   (*  group execute permission  *)
  PERM_GROUP_SRCH = 40H;   (*  group search permission  *)
  PERM_GROUP_WRITE = 20H;   (*  group write permission  *)
  PERM_GROUP_READ = 10H;   (*  group read permission  *)
  PERM_GROUP_MASK = 0F0H;   (*  group mask permission  *)
  PERM_OWNER_EXEC = 4H;   (*  owner execute permission  *)
  PERM_OWNER_SRCH = 4H;   (*  owner search permission  *)
  PERM_OWNER_WRITE = 2H;   (*  owner write permission  *)
  PERM_OWNER_READ = 1H;   (*  owner read permission  *)
  PERM_OWNER_MASK = 0FH;   (*  owner mask permission  *)

(*  * RBF open access modes  *)


CONST 
  O_RDONLY = 1H;   (*  open for read access  *)
  O_WRONLY = 2H;   (*  open for write access  *)
  O_RDWR = 3H;   (*  open for update access  *)
  O_EXECDIR = 4H;   (*  open for execute  *)
  O_TRUNC = 100H;   (*  truncate file to 0 if exists  *)
  O_CONTIG = 200H;   (*  ensure contiguous create  *)
  O_EXCL = 400H;   (*  error if file exists on create  *)
  O_CREAT = 800H;   (*  create file  *)
  O_APPEND = 1000H;   (*  force writes to eof (append)  *)
  O_ISIZE = 2000H;   (*  give initial size on create  *)
  O_SINGLE = 4000H;   (*  exclusive access  *)
  O_DIRECT = 8000H;   (*  directory access  *)
  O_BLKMODE = 10000H;   (*  block oriented @ mode  *)

(*  * device format word bit definitions  *)

CONST 
  FMT_DBLTRK0 = 1H;   (*  track 0 is double density  *)
  FMT_DBLBITDNS = 2H;   (*  device is double bit density  *)
  FMT_DBLTRKDNS = 4H;   (*  device is double track density  *)
  FMT_DBLSIDE = 8H;   (*  device is double sided  *)
  FMT_EIGHTINCH = 10H;   (*  drive is eight inch  *)
  FMT_FIVEINCH = 20H;   (*  drive is five inch  *)
  FMT_THREEINCH = 40H;   (*  drive is three inch  *)
  FMT_HIGHDENS = 1000H;   (*  device is high density  *)
  FMT_STDFMT = 2000H;   (*  device is standard format  *)
  FMT_REMOVABLE = 4000H;   (*  media can be removed  *)
  FMT_HARDISK = 8000H;   (*  device is a hard disk  *)

(*  * control word bit definitions  *)

CONST 
  CTRL_FMTDIS = 1H;   (*  device cannot be formatted  *)
  CTRL_MULTI = 2H;   (*  device can transfer multi sectors  *)
  CTRL_AUTOSIZE = 4H;   (*  device can find its size  *)
  CTRL_FMTENTIRE = 8H;   (*  can format entire device  *)
  CTRL_TRKWRITE = 10H;   (*  do track writes for format  *)
  CTRL_NOWRITE = 20H;   (*  no write on device if no change  *)
  CTRL_RDONLY = 40H;   (*  do not allow writes on device  *)

(*  * step rate constant definitions  *)

CONST 
  STEP_30MS = 0H;   (*  30 ms  *)
  STEP_20MS = 1H;   (*  20 ms  *)
  STEP_12MS = 2H;   (*  12 ms  *)
  STEP_6MS = 3H;   (*  6 ms  *)

(*  * v_useflags field definitions from rbf_drv_info structure  *)

CONST 
  NO_SS_DELBLK = 1H;   (*  device does not support SS_DELBLK  *)

(*  * SCSI Options bit defintions - these are applicable to SCSI based hardware  *)
(*  * only.                                                                      *)

CONST 
  SCSI_ATN = 1H;   (*    attention supported -- drive supports    *)
                   (*  * SCSI attention and standard messageing.  *)
                   (*  * (required for disconnect support.)       *)
  SCSI_PARITY = 2H;   (*  enable parity checking on data transfers.      *)
                      (*  * Drivers should set the up controllers to     *)
                      (*  * generate PARITY.  This flag indicates that   *)
                      (*  * parity should be checked on incomming data.  *)
  SCSI_SYNC = 4H;   (*    drive supports synchronous data transfer  *)
                    (*  * This would cause the driver to negotiate  *)
                    (*  * for synchronous transfers.                *)
  SCSI_WIDE = 8H;   (*    drive may support SCSI-II "wide" bus    *)
                    (*  * (16 bit transfers.)  This would cause   *)
                    (*  * the driver to negotiate for wide bus    *)
                    (*  * transfers. ( implies ATN is also set )  *)
  SCSI_TARGET = 10H;   (*    This unit should function as a target    *)
                       (*  * device on the SCSI bus.  We currently    *)
                       (*  * have no drivers that can do this but...  *)
  SCSI_ULTRA = 20H;   (*                            drive supports SCSI FAST20/40 protocol  *)
                      (* 							 * This includes ULTRA1 and ULTRA2                          *)
                      (* 							 * support                                                  *)
                      (* 							                                                            *)
  SCSI_SLOW = 40H;   (*                           Setting this bit forces maximun period  *)
                     (* 							 * during synchronous transfers to 200ns                   *)
                     (* 							 * (5MBs). NOTE: SCSI_SYNC must also be                    *)
                     (* 							 * defined to use this flag.                               *)
                     (* 							                                                           *)


(*  * number of entry points into rbf file manager  *)

CONST 
  RBF_ENTRY_POINTS = 16;

(*  * Defined RBF capability strings used by the SS_CAPABILITIES get status call.  *)

CONST 
  RBF_CAP_BLKMODE = ':BLOCK_MODE:';   (*  Indicates this version of RBF is  *)
                                      (*  capable of block mode transfers.                               *)
(*  * pointer to structure typedefs   *)

TYPE 
  fd_stats = RECORD
    fd_sync  : types.u_int32;  (*  file descriptor sync field  *)
    fd_parity: types.u_int32;  (*  validation parity  *)
    fd_flag  : types.u_int32;  (*  flag word  *)
    fd_host  : types.u_int16;  (*  file host owner  *)
    fd_group : types.u_int16;  (*  file group number  *)
    fd_owner : types.u_int16;  (*  file owner number  *)
    fd_links : types.u_int16;  (*  number of links to FD  *)
    fd_size  : types.u_int32;  (*  size of file in bytes  *)
    fd_ctime : time.time_t;    (*  creation timestamp  *)
    fd_atime : time.time_t;    (*  last access timestamp  *)
    fd_mtime : time.time_t;    (*  last modified timestamp  *)
    fd_utime : time.time_t;    (*  last changed timestamp  *)
    fd_btime : time.time_t;    (*  last backed up timestamp  *)
    fd_rev   : types.u_int16;  (*  rbf revision that wrote this  *)
    fd_unused: types.u_int16;  (*  spare  *)
  END;

  Fd_stats = POINTER TO fd_stats;   (*  file descriptor info  *)

  fd_segment = RECORD
    seg_offset: types.u_int32;  (*  segment block offset  *)
    seg_count : types.u_int32;  (*  segment block count  *)
  END;

  Fd_segment = POINTER TO fd_segment;   (*  segment in fd block  *)

  fd_links = RECORD
    link_prev: types.u_int32;  (*  previous fd block  *)
    link_next: types.u_int32;  (*  next fd block  *)
  END;

  Fd_links = POINTER TO fd_links;   (*  link segment in fd block  *)

  Fdl_list = POINTER TO fdl_list;

  Blockbuf = POINTER TO blockbuf;

  fd_blkinfo_struct = RECORD
    fdl_prev       : Fdl_list;           (*  previous link in segment list  *)
    fdl_next       : Fdl_list;           (*  next link in segment list  *)
    fdl_lbeg       : types.u_int32;  (*  logical beginning  *)
    fdl_size       : types.u_int32;  (*  total size of all segments in this blk  *)
    fdl_blknum     : types.u_int32;  (*  block number for this block  *)
    fdl_blklist    : Blockbuf;           (*  list of buffered blocks  *)
    fdl_blk_rsrc_lk: lock.lk_desc;   (*  the block list's lock  *)
    fdl_rsrc_lk    : lock.lk_desc;   (*  the fd list's lock  *)
  END;

  Fd_blkinfo = POINTER TO fd_blkinfo_struct;   (*  information about fd block  *)

  fd_blkinfo = fd_blkinfo_struct;

  fdl_list = RECORD
    fdl_info: fd_blkinfo;  (*  the info about this fd block  *)
    fdl_blk : fd_stats;    (*  the actual fd block  *)
  END;

(* Type 'Fdl_list' was declared here in the source file *)   (*  fd block list element  *)

  idblock = RECORD
    rid_sync     : types.u_int32;        (*  ID block sync pattern  *)
    rid_diskid   : types.u_int32;        (*  disk ID number (psuedo random)  *)
    rid_totblocks: types.u_int32;        (*  total blocks on media  *)
    rid_cylinders: types.u_int16;        (*  number of cylinders  *)
    rid_cyl0size : types.u_int16;        (*  cylinder 0 size in blocks  *)
    rid_cylsize  : types.u_int16;        (*  cylinder size in blocks  *)
    rid_heads    : types.u_int16;        (*  number of surfaces on disk  *)
    rid_blocksize: types.u_int16;        (*  the size of a block in bytes  *)
    rid_format   : types.u_int16;        (*  disk format  *)
    rid_flags    : types.u_int16;        (*  various flags  *)
    rid_unused1  : types.u_int16;        (*  32 bit padding  *)
    rid_bitmap   : types.u_int32;        (*  block offset to bitmap FD  *)
    rid_firstboot: types.u_int32;        (*  block offset to low level booter FD  *)
    rid_bootfile : types.u_int32;        (*  block offset to bootfile FD  *)
    rid_rootdir  : types.u_int32;        (*  block offset to root directory  *)
    rid_group    : types.u_int16;        (*  group owner of media  *)
    rid_owner    : types.u_int16;        (*  owner of media  *)
    rid_ctime    : time.time_t;          (*  creation time of media  *)
    rid_mtime    : time.time_t;          (*  time of last write to ID block  *)
    rid_name     : ARRAY [0..32-1] OF CHAR;  (*  volume name  *)
    rid_endflag  : CHAR;                     (*  big/little endian padding  *)
    rid_unused2  : ARRAY [0..3-1] OF CHAR;   (*  long word padding  *)
    rid_parity   : types.u_int32;        (*  id block parity  *)
  END;

  Idblock = POINTER TO idblock;   (*  disk id block  *)

  dirent = RECORD
    dir_name   : ARRAY [0..(MAXNAME+1)-1] OF CHAR;  (*  name of file  *)
    (* sizeof(u_int32) *)
    dir_unused : ARRAY [0..(((DIRENTSIZE-MAXNAME)-4)-1)-1] OF CHAR; (* 4 = SIZE(u_int32) *)
    dir_fd_addr: types.u_int32;                 (*  where file's fd is  *)
  END;

  Dirent = POINTER TO dirent;   (*  directory entry  *)

  blockbuf = RECORD
    bk_lsn     : types.u_int32;  (*  file relative lsn  *)
    bk_users   : types.u_int32;  (*  number of processes wanting this blk  *)
    bk_flags   : types.u_int32;  (*  block state flags  *)
    bk_size    : types.u_int32;  (*  size of the block  *)
    bk_rsrc_lk : lock.lk_desc;   (*  lock for this block  *)
    bk_lastpath: types.path_id;  (*  last path using this block  *)
    bk_next    : Blockbuf;           (*  next block in the block list  *)
    bk_buffer  : types.Ptru_char;      (*  buffer for this block  *)
  END;

(* Type 'Blockbuf' was declared here in the source file *)   (*  block buffer structure  *)

  rbf_fm_stat = RECORD
    count: types.u_int32;                             (*  number of entries in table  *)
    func : ARRAY [0..RBF_ENTRY_POINTS-1] OF types.ProcBYTEu32;  (*  the dispatch table  *)
  END;

  Rbf_fm_stat = POINTER TO rbf_fm_stat;   (*  file manager static storage  *)

  rbf_drvr_stat = RECORD
    funcs         : types.u_int32;     (*  number of functions  *)
    v_init        : types.ProcBYTEu32;           (*  address of driver init routine  *)
    v_read        : types.ProcBYTEu32;           (*  address of driver read routine  *)
    v_write       : types.ProcBYTEu32;           (*  address of driver write routine  *)
    v_getstat     : types.ProcBYTEu32;           (*  address of driver getstat routine  *)
    v_setstat     : types.ProcBYTEu32;           (*  address of driver setstat routine  *)
    v_term        : types.ProcBYTEu32;           (*  address of device terminate routine  *)
    v_drvr_rsrc_id: lock.lock_id;      (*  the driver resource id  *)
    v_busy        : types.process_id;  (*  process using the device  *)
    v_wake        : types.process_id;  (*  for use by the driver  *)
  END;

  Rbf_drvr_stat = POINTER TO rbf_drvr_stat;   (*  rbf driver static storage  *)

  Rbf_path_desc = POINTER TO rbf_path_desc;

  Ptrfreeblk = POINTER TO freeblk;

  Rbf_path_opts = POINTER TO rbf_path_opts;

  rbf_drv_info = RECORD
    v_0              : idblock;                              (*  standard id block stuff  *)
    (*  --> note alignment here <--  *)
    v_file_rsrc_lk   : lock.lk_desc;                     (*  the file list lock  *)
    v_filehd         : Rbf_path_desc;                        (*  list of open files on drive  *)
    v_free_rsrc_lk   : lock.lk_desc;                     (*  free list lock  *)
    v_free           : Ptrfreeblk;                       (*  pointer to free list structure  *)
    v_freesearch     : Ptrfreeblk;                       (*  start search here for free space  *)
    v_diskid         : types.u_int32;                    (*  disk ID number  *)
    v_mapseg         : fd_segment;                           (*  the bitmap segment  *)
    v_bkzero         : Idblock;                              (*  ptr to block zero buffer  *)
    v_resbit         : types.u_int32;                    (*  reserved bitmap block number (if any)  *)
    v_trak           : types.u_int32;                    (*  current track number  *)
    v_softerr        : types.u_int32;                    (*  recoverable error count  *)
    v_harderr        : types.u_int32;                    (*  non-recoverable error count  *)
    v_cache          : Ptrfreeblk;                       (*  drive cache information ptr  *)
    v_crsrc_lk       : lock.lk_desc;                     (*  cache lock  *)
    v_numpaths       : types.u_int16;                    (*  number of open paths on this device  *)
    v_zerord         : types.u_char;                     (*  block zero read flag  *)
    v_init           : types.u_char;                     (*  drive initialized flag  *)
    v_dopts          : Rbf_path_opts;                        (*  copy of the default opts  *)
    v_endflag        : types.u_char;                     (*  big/little endian flag  *)
    v_useflags       : types.u_char;                     (*  flags field for use  *)
    v_dumm2          : ARRAY [0..2-1] OF types.u_char;   (*  reserved  *)
    v_fd_free_rsrc_lk: lock.lk_desc;                     (*  lock for fd free list  *)
    v_fd_free_list   : Fdl_list;                             (*  list of free fd blocks  *)
    v_blks_rsrc_lk   : lock.lk_desc;                     (*  free block buffer list lock  *)
    v_blks_list      : Blockbuf;                             (*  free block buffer list  *)
    v_reserved       : ARRAY [0..4-1] OF types.u_int32;  (*  for future expansions  *)
  END;

  rbf_lu_opts = RECORD
    lu_stp     : types.u_char;                     (*  the step rate  *)
    lu_tfm     : types.u_char;                     (*  the dma transfer mode  *)
    lu_lun     : types.u_char;                     (*  drive logical unit number  *)
    lu_ctrlrid : types.u_char;                     (*  the controller id  *)
    lu_totcyls : types.u_int32;                    (*  total number of cylinders  *)
    lu_reserved: ARRAY [0..4-1] OF types.u_int32;  (*  reserved for future expansion  *)
  END;

  rbf_lu_stat = RECORD
    v_driveinfo: rbf_drv_info;       (*  the drive's information  *)
    v_vector   : types.u_char;   (*  the interrupt vector  *)
    v_irqlevel : types.u_char;   (*  the interrupt level  *)
    v_priority : types.u_char;   (*  the interrupt priority  *)
    v_unused   : types.u_char;   (*  unused byte  *)
    v_luopt    : rbf_lu_opts;        (*  logical unit options  *)
    v_capstr   : types.PtrSChar;       (*  capabilities string  *)
    v_reserved : types.u_int32;  (*  reserved for future expansions  *)
  END;

  Rbf_lu_stat = POINTER TO rbf_lu_stat;   (*  descriptor contents  *)

(* Type 'rbf_lu_opts' was declared here in the source file *)

  Rbf_lu_opts = POINTER TO rbf_lu_opts;   (*  rbf logical unit options  *)

(* Type 'rbf_drv_info' was declared here in the source file *)

  Rbf_drv_info = POINTER TO rbf_drv_info;   (*  rbf disk static storage  *)

  rbf_path_opts = RECORD
    pd_sid     : types.u_int32;                    (*  number of surfaces  *)
    pd_vfy     : types.u_int32;                    (*  0=verify disk writes  *)
    pd_format  : types.u_int32;                    (*  device format  *)
    pd_cyl     : types.u_int32;                    (*  number of cylinders  *)
    pd_blk     : types.u_int32;                    (*  default blocks/track  *)
    pd_t0b     : types.u_int32;                    (*  default blocks/track for trk0/sec0  *)
    pd_sas     : types.u_int32;                    (*  segment allocation size  *)
    pd_ilv     : types.u_int32;                    (*  block interleave offset  *)
    pd_toffs   : types.u_int32;                    (*  track base offset  *)
    pd_boffs   : types.u_int32;                    (*  block base offset  *)
    pd_trys    : types.u_int32;                    (*  # tries  *)
    pd_bsize   : types.u_int32;                    (*  size of block in bytes  *)
    pd_cntl    : types.u_int32;                    (*  control word  *)
    pd_wpc     : types.u_int32;                    (*  first write precomp cylinder  *)
    pd_rwr     : types.u_int32;                    (*  first reduced write current cylinder  *)
    pd_park    : types.u_int32;                    (*  park cylinder for hard disks  *)
    pd_lsnoffs : types.u_int32;                    (*  lsn offset for partition  *)
    pd_xfersize: types.u_int32;                    (*  max transfer size in terms of bytes  *)
    pd_reserved: ARRAY [0..4-1] OF types.u_int32;  (*  reserved for future expansions  *)
  END;

(* Type 'Rbf_path_opts' was declared here in the source file *)   (*  the path options  *)

  rbf_path_desc = RECORD
    pd_io          : io.pd_com;                        (*  ioman section  *)
    pd_buf         : types.Ptru_char;                        (*  buffer pointer  *)
    pd_fsmf        : types.u_char;                     (*  fd state flags  *)
    pd_lock        : types.u_char;                     (*  path lockout status  *)
    pd_req         : types.u_char;                     (*  requested lockout status  *)
    pd_bsbt        : types.u_char;                     (*  disk block size (bit number)  *)
    pd_openok      : types.u_char;                     (*  file was opened without error  *)
    pd_append      : types.u_char;                     (*  file is being appended  *)
    pd_xfermode    : types.u_char;                     (*  flags for disk mode  *)
    pd_cblk        : Blockbuf;                             (*  current block  *)
    pd_rfd         : Fdl_list;                             (*  root FD structure pointer  *)
    pd_cfd         : Fdl_list;                             (*  pointer to FD structure containing pd_seg  *)
    pd_cp          : types.u_int32;                    (*  current logical byte position  *)
    pd_siz         : types.u_int32;                    (*  file size  *)
    pd_sbl         : types.u_int32;                    (*  segment beginning lsn  *)
    pd_sbp         : types.u_int32;                    (*  segment beginning psn  *)
    pd_ssz         : types.u_int32;                    (*  segment size  *)
    pd_dsk         : types.u_int32;                    (*  disk ID  *)
    pd_conf_rsrc_id: lock.lock_id;                     (*  the conflict list resource id  *)
    pd_nxfil       : Rbf_path_desc;                        (*  drive open file list ptr  *)
    pd_conf        : Rbf_path_desc;                        (*  file conflict list ptr  *)
    pd_seg         : Fd_segment;                           (*  the current segment  *)
    pd_owner       : types.process_id;                 (*  process ID of owner of desired segment  *)
    pd_accs        : types.u_int32;                    (*  allowable file access permissions  *)
    pd_lolck       : types.u_int32;                    (*  low locked logical address  *)
    pd_hilck       : types.u_int32;                    (*  high locked logical address  *)
    pd_wait_rsrc_id: lock.lock_id;                     (*  wait list resource id  *)
    pd_wait        : Rbf_path_desc;                        (*  ptr to next locked out pathdesc  *)
    pd_tmout       : types.u_int32;                    (*  max ticks to wait for locked segment  *)
    pd_prior       : types.u_int32;                    (*  temp for proc priority while in driver  *)
    pd_fd          : types.u_int32;                    (*  lsn of file descriptor  *)
    pd_dfd         : types.u_int32;                    (*  directory file descriptor lsn  *)
    pd_dcp         : types.u_int32;                    (*  directory entry ptr  *)
    pd_dvt         : types.u_int32;                    (*  device table ptr (copy)  *)
    pd_att         : types.u_int32;                    (*  file attributes  *)
    pd_name        : ARRAY [0..MAXNAME-1] OF CHAR;         (*  filename  *)
    pd_useflags    : types.u_int32;                    (*  flags field for general use  *)
    pd_reserved    : ARRAY [0..3-1] OF types.u_int32;  (*  reserved for future expansions  *)
    pd_opts        : rbf_path_opts;                        (*  the option section  *)
  END;

(* Type 'Rbf_path_desc' was declared here in the source file *)   (*  the path descriptor  *)

  rbf_desc = RECORD
    dd_descom : io.dd_com;  (*  common header info  *)
    dd_pathopt: rbf_path_opts;  (*  the path options  *)
  END;

  Rbf_desc = POINTER TO rbf_desc;   (*  device descriptor  *)

(*                                                              *)
(*  * File descriptor structure definition.  File descriptor    *)
(*  * blocks for a particular file are organized in a doubly    *)
(*  * linked list.  A file descriptor may contain file data     *)
(*  * if the file is sufficently small.  The back link of the   *)
(*  * first file descriptor points to the last fd block.  The   *)
(*  * forward link of the last file descriptor is the first     *)
(*  * file descriptor.                                          *)
(*                                                              *)

(* Type 'fd_stats' was declared here in the source file *)

(*                                             *)
(*  * structure for a segment in the FD block  *)
(*                                             *)

(* Type 'fd_segment' was declared here in the source file *)

(*                                                              *)
(*  * structure for the next and previous fd block pointers in  *)
(*  * the last segment.                                         *)
(*                                                              *)
(*                                           *)
(*  * structure used for segment list info.  *)
(*                                           *)

(* Type 'fd_blkinfo' was declared here in the source file *)

(*                                           *)
(*  * structure for a segment list element   *)
(*                                           *)
(*                                                             *)
(*  * Structure for RBF ID block.  This block is stored at     *)
(*  * various locations on the disk specified at format time.  *)
(*                                                             *)

(* Type 'idblock' was declared here in the source file *)

(*                                *)
(*  * directory entry structure   *)
(*                                *)
(*                              *)
(*  * buffered block structure  *)
(*                              *)
(*                                     *)
(*  * definitions for rbf drive table  *)
(*                                     *)

  freeblk = RECORD
    (* Declaration without definition *)
  END;

  cachedriv = freeblk;

(* Type 'rbf_drv_info' was declared here in the source file *)

<* IF NOT DEFINED(_cache) THEN *>
  cachestats = RECORD
    c_read_requests      : types.u_int32;
    c_blocks_read        : types.u_int32;
    c_read_hits          : types.u_int32;
    c_read_zaps          : types.u_int32;
    c_multi_sector_reads : types.u_int32;
    c_sector_zero_reads  : types.u_int32;
    c_write_requests     : types.u_int32;
    c_blocks_written     : types.u_int32;
    c_write_zaps         : types.u_int32;
    c_multi_sector_writes: types.u_int32;
    c_dir_reads          : types.u_int32;
    c_dir_blocks_read    : types.u_int32;
    c_dir_hits           : types.u_int32;
    c_dir_writes         : types.u_int32;
    c_dir_blocks_written : types.u_int32;
    c_woofs              : types.u_int32;
    c_errors             : types.u_int32;
    c_misses             : types.u_int32;
    c_hit_compares       : types.u_int32;
    c_miss_compares      : types.u_int32;
  END;

  Cachestats = POINTER TO cachestats;
<* END *>

(*  OS-9 file descriptor for those who want to us _gs_gfd and/or _ss_pfd  *)

  Struct = RECORD
    group: types.u_char;  (*  file owner (group)  *)
    user : types.u_char;  (*  file owner (user)  *)
  END;

  Union = RECORD
    CASE : INTEGER OF
       0: owner: Struct;
      |1: own  : ARRAY [0..2-1] OF types.u_char;
    END;
  END;

  Struct0 = RECORD
    (*  segment entry structure  *)
    addr: ARRAY [0..3-1] OF types.u_char;  (*  segment begin LSN  *)
    size: ARRAY [0..2-1] OF types.u_char;  (*  segment size in sectors  *)
  END;

  fd = RECORD
    fd_att  : types.u_char;                    (*  file attributes  *)
    fd_own  : Union;
    fd_date : ARRAY [0..5-1] OF types.u_char;  (*  data last modified  *)
    fd_link : types.u_char;                    (*  link count  *)
    fd_fsize: types.u_int;                     (*  file size  *)
    fd_dcr  : ARRAY [0..3-1] OF types.u_char;  (*  data created  *)
    fdseg   : ARRAY [0..48-1] OF Struct0;      (*  256 byte fd  *)
  END;

  Fd = POINTER TO fd;

PROCEDURE _os_gs_cstats ( arg0: types.path_id;
			  arg1: Cachestats ): types.error_code;

PROCEDURE _os_gs_dsize ( arg0: types.path_id; arg1: types.Ptru_int32;
			 arg2: types.Ptru_int32 ): types.error_code;

PROCEDURE _os_gs_fd ( arg0: types.path_id; arg1: types.u_int32;
		      arg2: Fd_stats ): types.error_code;

PROCEDURE _os_gs_fdaddr ( arg0: types.path_id;
			  arg1: types.Ptru_int32 ): types.error_code;

PROCEDURE _os_gs_fdinf ( arg0: types.path_id; arg1: types.u_int32;
			 arg2: types.u_int32;
			 arg3: Fd_stats ): types.error_code;

PROCEDURE _os_gs_parity ( arg0: types.path_id; arg1: Fd_stats;
			  arg2: types.Ptru_int32 ): types.error_code;

PROCEDURE _os_ss_cache ( arg0: types.path_id; arg1: types.u_int32;
			 arg2: types.u_int32 ): types.error_code;

PROCEDURE _os_ss_fd ( arg0: types.path_id; arg1: Fd_stats ): types.error_code;

PROCEDURE _os_ss_flushmap ( arg0: types.path_id ): types.error_code;

PROCEDURE _os_ss_hdlink ( arg0: types.path_id;
			  arg1: types.PtrPtrSChar ): types.error_code;

PROCEDURE _os_ss_lock ( arg0: types.path_id;
			arg1: types.u_int32 ): types.error_code;

PROCEDURE _os_ss_ticks ( arg0: types.path_id;
			 arg1: types.u_int32 ): types.error_code;

PROCEDURE _os_ss_wtrack ( arg0: types.path_id; arg1: SYSTEM.ADDRESS;
			  arg2: SYSTEM.ADDRESS; arg3: types.u_int32;
			  arg4: types.u_int32;
			  arg5: types.u_int32 ): types.error_code;

END rbf.
