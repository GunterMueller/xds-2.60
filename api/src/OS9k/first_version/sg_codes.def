(* sg_codes.def  Feb 27  13:52:2  2000 *)
(* Generated by H2D v1.31.0 from sg_codes.h. *)
<*+ M2ADDTYPES *>
<*+ M2EXTENSIONS *>
<*+ NOHEADER *> 
<* IF NOT DEFINED(GENTYPEDEF) THEN *> <* NEW GENTYPEDEF+ *> <* END *>

DEFINITION MODULE ["C"] sg_codes;

IMPORT types, SYSTEM;
(* H2D:  Required IMPORT clause: 
IMPORT sg_codes, types;
*)

CONST 
  SS_PATHOPT = 0H;   (*  read/write PD options						 *)
  SS_READY = 1H;   (*  check for device ready						 *)
  SS_SIZE = 2H;   (*  read/Write file size							 *)
  SS_RESET = 3H;   (*  device restore								 *)
  SS_WTRACK = 4H;   (*  device write track							 *)
  SS_POS = 5H;   (*  get file current position					 *)
  SS_EOF = 6H;   (*  test for End of File							 *)
  SS_LINK = 7H;   (*  link to Status routines						 *)
  SS_ULINK = 8H;   (*  unlink Status routines						 *)
  SS_FEED = 9H;   (*  destructive forward skip (form feed)			 *)
  SS_FREEZE = 0AH;   (*  freeze DD_ information						 *)
  SS_SPT = 0BH;   (*  set DD_TKS to given value					 *)
  SS_SQD = 0CH;   (*  sequence down hard disk						 *)
  SS_DCMD = 0DH;   (*  send direct command to device				 *)
  SS_DEVNAME = 0EH;   (*  return device name							 *)
  SS_FD = 0FH;   (*  return file descriptor						 *)
  SS_TICKS = 10H;   (*  set lockout honor duration					 *)
  SS_LOCK = 11H;   (*  lock/release record							 *)
  SS_DSTAT = 12H;   (*  return display status						 *)
  SS_JOY = 13H;   (*  return joystick value						 *)
  SS_BLKRD = 14H;   (*  block read									 *)
  SS_BLKWR = 15H;   (*  block write									 *)
  SS_RETEN = 16H;   (*  retension cycle								 *)
  SS_WFM = 17H;   (*  write file mark								 *)
  SS_RFM = 18H;   (*  read past file mark							 *)
  SS_ELOG = 19H;   (*  read error log								 *)
  SS_SENDSIG = 1AH;   (*  send signal on data ready					 *)
  SS_RELEASE = 1BH;   (*  release device								 *)
  SS_ATTR = 1CH;   (*  set file attributes							 *)
  SS_BREAK = 1DH;   (*  send break out serial device					 *)
  SS_RSBIT = 1EH;   (*  reserve bitmap sector (for disk reorg)		 *)
  SS_RMS = 1FH;   (*  get/set Motorola RMS status					 *)
  SS_FDINFO = 20H;   (*  get FD info for specified FD sector			 *)
  SS_ACRTC = 21H;   (*  get/set Hitachi ACRTC status					 *)
  SS_IFC = 22H;   (*  serial input flow control					 *)
  SS_OFC = 23H;   (*  serial output flow control					 *)
  SS_ENRTS = 24H;   (*  enable RTS (modem control)					 *)
  SS_DSRTS = 25H;   (*  disable RTS (modem control)					 *)
  SS_DCON = 26H;   (*  send signal DCD TRUE							 *)
  SS_DCOFF = 27H;   (*  send signal DCD FALSE						 *)
  SS_SKIP = 28H;   (*  skip block(s)								 *)
  SS_MODE = 29H;   (*  set RBF access mode							 *)
  SS_OPEN = 2AH;   (*  notification of new path opened				 *)
  SS_CLOSE = 2BH;   (*  notification of path being closed			 *)
  SS_SOUND = 2CH;   (*  produce audible sound						 *)
  SS_DSIZE = 2DH;   (*  get drive size (in sectors)					 *)
  SS_SEVENT = 2EH;   (*  set event on data ready						 *)
  SS_DEVTYPE = 2FH;   (*  get the device type 							 *)
  SS_DEVOPT = 79H;   (*  get/set device (default) path options 		 *)
  SS_EDT = 7AH;   (*  file manager - device driver edition getstat  *)
  SS_RENAME = 7BH;   (*  rename current file							 *)
  SS_FILLBUFF = 7CH;   (*  fill the path buffer							 *)
  SS_SHOWUSE = 7DH;   (*  show the use count of driver/fm functions	 *)
  SS_FdAddr = 7EH;   (*  get fd block address for open file			 *)
  SS_HDLINK = 7FH;   (*  create a hard link to a(n rbf) file			 *)
  SS_LUOPT = 80H;   (*  get/set logical unit options					 *)
  SS_DELBLK = 81H;   (*  notify driver of deleted block				 *)
  SS_CACHE = 30H;   (*  cache enable setstat code 					 *)
  SS_CSTATS = 31H;   (*  get cache statistics getstat code			 *)
  SS_PARITY = 32H;   (*  compute the parity of a block				 *)
  SS_SKIPEND = 33H;   (*  skip to end of recorded data on a tape		 *)
  SS_FLUSHMAP = 34H;   (*  flush rbf bitmap                     		 *)
  SS_COPYPD = 35H;   (*  Copy path descriptor get status				 *)
  SS_CAPABILITIES = 36H;   (*  get capabilities string					 *)
  SS_LINK_ADJ = 37H;   (*  adjust FD link count							 *)
  SS_SYMLINK = 38H;   (*  Create a symbolic link to a file				 *)
  SS_FREE = 43H;   (*  Return free space get status					 *)
  SS_VOLSTORE = 45H;   (*  Return volume storage statistics getstat		 *)
  SS_DISKFREE = 47H;   (*  Get disk free space information               *)
  SS_ISDN = 47H;   (*  Get/Set Stat code for ISDN (with subcodes)	 *)
  SS_PMOD = 48H;   (*  Protocol Module get/setstat, with subcodes	 *)
  SS_SPF = 48H;   (*  SPF getstat/setstat with subcodes			 *)
  SS_RTNFM = 49H;   (*  Real-Time Network FM get/setstat w/ subcodes  *)

(*                               *)
(* 	Get/Set Stat codes for GFM   *)
(*                               *)

CONST 
  SS_SM = 4EH;   (*  GFM's soundmap control status code			 *)
  SS_SD = 4FH;   (*  GFM's sound data manipulation status code	 *)
  SS_SC = 50H;   (*  GFM's sound control status code				 *)
  SS_DM = 51H;   (*  GFM's drawmap control status code			 *)
  SS_GC = 52H;   (*  GFM's graphics cursor status code			 *)
  SS_RG = 53H;   (*  GFM's region status code						 *)
  SS_DP = 54H;   (*  GFM's drawing parameters status code			 *)
  SS_DR = 55H;   (*  GFM's graphics drawing status code			 *)
  SS_DC = 56H;   (*  GFM's display control status code			 *)
  SS_VIQ = 57H;   (*  GFM's video inquiry status code				 *)
  SS_CO = 58H;   (*  GFM's character output status code			 *)
  SS_PT = 59H;   (*  GFM's pointer status code					 *)
  SS_KB = 5BH;   (*  GFM's keyboard status code 					 *)

(*                                          *)
(* 	Get/SetStat function codes for sockets  *)
(*                                          *)

CONST 
  SS_Bind = 6CH;   (*  bind a socket name							 *)
  SS_Listen = 6DH;   (*  listen for connections						 *)
  SS_Connect = 6EH;   (*  initiate a connection						 *)
  SS_Resv = 6FH;   (*  socket characteristics specification			 *)
  SS_Accept = 70H;   (*  accept socket connections					 *)
  SS_Recv = 71H;   (*  receive data									 *)
  SS_Send = 72H;   (*  send data									 *)
  SS_GNam = 73H;   (*  get socket name								 *)
  SS_SOpt = 74H;   (*  set socket option							 *)
  SS_GOpt = 75H;   (*  get socket option							 *)
  SS_Shut = 76H;   (*  shutdown socket connection					 *)
  SS_SendTo = 77H;   (*  send to address								 *)
  SS_RecvFr = 78H;   (*  receive from address							 *)
  SS_Install = 79H;   (*  install upper level protocol (ULP)  *)

(*  handler on ifman list  *)

CONST 
  SS_PCmd = 7AH;   (*  protocol direct command  *)

(*  more GFM and CDFM codes  *)

CONST 
  SS_SN = 8CH;   (*  GFM's screen functions 						 *)
  SS_AR = 8DH;   (*  GFM's action region functions 				 *)
  SS_AC = 8FH;   (*  GFM's action cursor functions 				 *)
  SS_MS = 8EH;   (*  GFM's message functions 						 *)
  SS_CDFD = 90H;   (*  CDFM return file descriptor information  *)
  SS_CChan = 91H;   (*  CDFM change channel request  *)
  SS_FG = 92H;   (*  GFM's frame grabber functions				 *)
  SS_SOCKMAN = 94H;   (*  Sockman get/setstat code with subcodes.		 *)

(*                          *)
(* 	Function codes for GFM  *)
(*                          *)
(*  SS_SM setstat function codes  *)

CONST 
  SM_CREAT = 1;   (*  create soundmap  *)
  SM_OUT = 2;   (*  output soundmap  *)
  SM_OFF = 3;   (*  stop output of soundmap  *)
  SM_CLOSE = 4;   (*  close a soundmap  *)
  SM_LOOP = 5;   (*  set soundmap looping  *)
  SM_IN = 6;   (*  input soundmap  *)

(*  SS_SM getstat function codes  *)

CONST 
  SM_INFO = 1;   (*  get soundmap info  *)
  SM_STAT = 2;   (*  get soundmap status  *)

(*  SS_FG setstat function codes  *)

CONST 
  FG_GRAB = 1;   (*  grab one frame  *)
  FG_GAIN = 2;   (*  set frame grabber gain  *)
  FG_OFFSET = 3;   (*  set frame grabber voltage offset  *)

(*  SS_FG getstat function codes  *)

CONST 
  FG_INFO = 1;   (*  get frame grabber information  *)

(*  SS_DM function codes  *)

CONST 
  DM_CREAT = 1;   (*  create drawmap  *)
  DM_ORG = 2;   (*  set drawmap origin  *)
  DM_COPY = 3;   (*  copy drawmap to drawmap  *)
  DM_EXCH = 4;   (*  exchange drawmap to drawmap  *)
  DM_TCPY = 5;   (*  copy drawmap to drawmap with transparency  *)
  DM_TEXC = 6;   (*  exchange drawmap to drawmap with transparency  *)
  DM_WRITE = 7;   (*  write data to drawmap  *)
  DM_IRWR = 8;   (*  irregular write to drawmap  *)
  DM_READ = 9;   (*  read data from drawmap  *)
  DM_WRPIX = 10;   (*  write a pixel  *)
  DM_RDPIX = 11;   (*  read a pixel  *)
  DM_CLOSE = 12;   (*  close drawmap  *)
  DM_DMDUP = 13;   (*  duplicate a drawmap  *)

(*  SS_GC function codes  *)

CONST 
  GC_POS = 1;   (*  position graphics cursor  *)
  GC_SHOW = 2;   (*  show graphics cursor  *)
  GC_HIDE = 3;   (*  hide graphics cursor  *)
  GC_PTN = 4;   (*  set graphics cursor pattern  *)
  GC_COL = 5;   (*  set graphics cursor color  *)
  GC_ORG = 6;   (*  set graphics cursor origin  *)

(*  SS_RG function codes  *)

CONST 
  RG_CREAT = 1;   (*  create region  *)
  RG_ISECT = 2;   (*  region intersection  *)
  RG_UNION = 3;   (*  region union  *)
  RG_DIFF = 4;   (*  region difference  *)
  RG_XOR = 5;   (*  region XOR  *)
  RG_MOVE = 6;   (*  region move  *)
  RG_DEL = 7;   (*  delete a region  *)

(*  SS_DP function codes  *)

CONST 
  DP_PTN = 1;   (*  set draw pattern  *)
  DP_PALN = 2;   (*  set pattern alignment  *)
  DP_SCMM = 3;   (*  set character mapping method  *)
  DP_SCR = 4;   (*  set color register  *)
  DP_GFNT = 5;   (*  get a font  *)
  DP_AFNT = 6;   (*  activate a font  *)
  DP_DFNT = 7;   (*  deactivate a font  *)
  DP_RFNT = 8;   (*  release a font  *)
  DP_CLIP = 9;   (*  set clipping region  *)
  DP_PNSZ = 10;   (*  set pen size  *)
  DP_PSTYL = 11;   (*  set pen style  *)
  DP_TCOL = 12;   (*  set transparency color  *)

(*  SS_DR function codes  *)

CONST 
  DR_DOT = 1;   (*  draw a dot  *)
  DR_LINE = 2;   (*  draw a line  *)
  DR_PLIN = 3;   (*  draw a poly-line  *)
  DR_CARC = 4;   (*  draw a circular arc  *)
  DR_EARC = 5;   (*  draw an elliptical arc  *)
  DR_RECT = 6;   (*  draw a rectangle  *)
  DR_ERECT = 7;   (*  draw an elliptical cornered rectangle  *)
  DR_PGON = 8;   (*  draw a polygon  *)
  DR_CIRC = 9;   (*  draw a circle  *)
  DR_CWDG = 10;   (*  draw a circular wedge  *)
  DR_ELPS = 11;   (*  draw an ellipse  *)
  DR_EWDG = 12;   (*  draw an elliptical wedge  *)
  DR_DRGN = 13;   (*  draw a region  *)
  DR_BFIL = 14;   (*  border fill  *)
  DR_FFIL = 15;   (*  flood fill  *)
  DR_COPY = 16;   (*  copy data in a drawmap  *)
  DR_TEXT = 17;   (*  draw text  *)
  DR_JTXT = 18;   (*  draw justified text  *)

(*  SS_DC setstat function codes  *)

CONST 
  DC_SENDSIG = 1;   (*  send signal on video event  *)
  DC_RELEASE = 2;   (*  release pending signal  *)
  DC_SETCLUT = 3;   (*  set a clut  *)
  DC_SETCLUTS = 4;   (*  set a range of cluts  *)
  DC_MAPDM = 5;   (*  map a drawmap  *)
  DC_OFF = 6;   (*  turn off display  *)

(*  SS_DC getstat function codes  *)

CONST 
  DC_DSPLSIZ = 1;   (*  get the display size and characteristics  *)
  DC_GETCLUT = 2;   (*  get a clut  *)
  DC_GETCLUTS = 3;   (*  get a range of cluts  *)
  DC_EVENT = 4;   (*  get event name  *)

(*  SS_VIQ getstat functions  *)

CONST 
  VIQ_TXTL = 1;   (*  calculate text length  *)
  VIQ_CPOS = 2;   (*  return relative character positions  *)
  VIQ_JCPS = 3;   (*  return character positions for justified text  *)
  VIQ_FDTA = 4;   (*  get font data  *)
  VIQ_GDTA = 5;   (*  get glyph data  *)
  VIQ_PNTR = 6;   (*  test for point in a region  *)
  VIQ_RLOC = 7;   (*  inquire region location  *)
  VIQ_RINFO = 8;   (*  return region info  *)
  VIQ_DMINFO = 9;   (*  return drawmap info  *)

(*  SS_CO setstat routines  *)

CONST 
  CO_COD = 1;   (*  set character output drawmap  *)
  CO_SCMM = 2;   (*  set character output map method  *)
  CO_AFNT = 3;   (*  activate font  *)
  CO_DFNT = 4;   (*  deactivate font  *)

(*  SS_PT setstat functions  *)

CONST 
  PT_SENDSIG = 1;   (*  send sig on pointer change  *)
  PT_RELEASE = 2;   (*  release pending signal  *)
  PT_POS = 3;   (*  position pointer  *)
  PT_ORG = 4;   (*  set pointer origin  *)
  PT_CALIB = 5;   (*  calibrate pointer (for touchscreen)  *)

(*  SS_PT getstat functions  *)

CONST 
  PT_COORD = 1;   (*  get pointer coords  *)

(*  SS_KB setstat functions  *)

CONST 
  KB_SENDSIG = 1;   (*  send signal on char ready  *)
  KB_RELEASE = 2;   (*  release pending signal  *)

(*  SS_KB getstat functions  *)

CONST 
  KB_RDY = 1;   (*  check keyboard ready  *)

(*  SS_SN setstat functions  *)

CONST 
  SN_OPEN = 1;   (*  open a screen  *)
  SN_CLOSE = 2;   (*  close a screen  *)
  SN_RAISE = 3;   (*  raise a screen  *)
  SN_LOWER = 4;   (*  lower a screen  *)
  SN_ACT = 5;   (*  activate a screen  *)
  SN_DEACT = 6;   (*  deactivate a screen  *)
  SN_CPACT = 7;   (*  activate cursor process for screen  *)
  SN_CPDEACT = 8;   (*  deactivate cursor process for screen  *)
  SN_ALINK = 9;   (*  link action region to screen  *)
  SN_CP = 10;   (*  run cp once for screen  *)
  SN_DMLINK = 11;   (*  link drawmap to screen  *)
  SN_CLUTLNK = 12;   (*  link clut to screen  *)

(*  SS_SN getstat functions  *)

CONST 
  SN_INFO = 1;   (*  return screen info  *)
  SN_GETACT = 2;   (*  return active screen  *)

(*  SS_AR setstat functions  *)

CONST 
  AR_OPEN = 1;   (*  open action region  *)
  AR_REDEFINE = 2;   (*  redefine action region  *)
  AR_CLOSE = 3;   (*  close action region  *)
  AR_CLOSESUB = 4;   (*  close sub-action regions  *)
  AR_RAISE = 5;   (*  raise action region  *)
  AR_LOWER = 6;   (*  lower action region  *)
  AR_ACT = 7;   (*  activate action region  *)
  AR_DEACT = 8;   (*  deactivate action region  *)
  AR_MOVE = 9;   (*  move action region  *)
  AR_MASK = 10;   (*  set action region mask  *)
  AR_UNGRAB = 11;   (*  ungrab messages  *)
  AR_GRAB = 12;   (*  grab messages  *)

(*  SS_AR getstat functions  *)

CONST 
  AR_INFO = 1;   (*  return action region info  *)
  AR_FIND = 2;   (*  find action region for a point  *)
  AR_RELXY = 3;   (*  return relative coordinates  *)
  AR_ABSXY = 4;   (*  return absolute coordinates  *)

(*  SS_MS setstat functions  *)

CONST 
  MS_READ = 1;   (*  read a message  *)
  MS_WRITE = 2;   (*  write a message  *)
  MS_UNREAD = 3;   (*  unread a message  *)
  MS_SENDSIG = 4;   (*  send signal on message  *)
  MS_RELEASE = 5;   (*  release signal pending  *)
  MS_FLUSH = 6;   (*  flush message queue  *)
  MS_JOURN = 7;   (*  journal messages  *)

(*  SS_MS getstat functions  *)

CONST 
  MS_STAT = 1;   (*  get input device status  *)
  MS_READY = 2;   (*  message ready?  *)

(*  SS_AC setstat functions  *)

CONST 
  AC_POS = 1;   (*  set action cursor position  *)
  AC_ACT = 2;   (*  activate action cursor  *)
  AC_DEACT = 3;   (*  deactivate action cursor  *)
  AC_PTN = 4;   (*  set pattern  *)
  AC_COL = 5;   (*  set color  *)
  AC_ORG = 6;   (*  set origin  *)
  AC_TRACK = 7;   (*  track action cursor  *)

PROCEDURE _os_getstat ( arg0: types.path_id; arg1: types.u_int32;
			arg2: SYSTEM.ADDRESS ): types.error_code;

PROCEDURE _os_gs_cpypd ( arg0: types.path_id; arg1: types.Ptru_int32;
			 arg2: SYSTEM.ADDRESS ): types.error_code;

PROCEDURE _os_gs_devnm ( arg0: types.path_id;
			 arg1: types.PtrSChar ): types.error_code;

PROCEDURE _os_gs_devtyp ( arg0: types.path_id; arg1: types.Ptru_int16;
			  arg2: types.Ptru_int16 ): types.error_code;

PROCEDURE _os_gs_dopt ( arg0: types.path_id; arg1: types.Ptru_int32;
			arg2: SYSTEM.ADDRESS ): types.error_code;

PROCEDURE _os_gs_eof ( arg0: types.path_id ): types.error_code;

PROCEDURE _os_gs_luopt ( arg0: types.path_id; arg1: types.Ptru_int32;
			 arg2: SYSTEM.ADDRESS ): types.error_code;

PROCEDURE _os_gs_popt ( arg0: types.path_id; arg1: types.Ptru_int32;
			arg2: SYSTEM.ADDRESS ): types.error_code;

PROCEDURE _os_gs_pos ( arg0: types.path_id;
		       arg1: types.Ptru_int32 ): types.error_code;

PROCEDURE _os_gs_ready ( arg0: types.path_id;
			 arg1: types.Ptru_int32 ): types.error_code;

PROCEDURE _os_gs_size ( arg0: types.path_id;
			arg1: types.Ptru_int32 ): types.error_code;

PROCEDURE _os_gs_capabilities ( arg0: types.path_id; arg1: types.PtrSChar;
				arg2: types.Ptru_int32 ): types.error_code;

PROCEDURE _os_setstat ( arg0: types.path_id; arg1: types.u_int32;
			arg2: SYSTEM.ADDRESS ): types.error_code;

PROCEDURE _os_sgetstat ( arg0: types.path_id; arg1: types.u_int32;
			 arg2: SYSTEM.ADDRESS ): types.error_code;

PROCEDURE _os_sgs_devnm ( arg0: types.path_id;
			  arg1: types.PtrSChar ): types.error_code;

PROCEDURE _os_ss_attr ( arg0: types.path_id;
			arg1: types.u_int32 ): types.error_code;

PROCEDURE _os_ss_break ( arg0: types.path_id ): types.error_code;

PROCEDURE _os_ss_dopt ( arg0: types.path_id; arg1: types.u_int32;
			arg2: SYSTEM.ADDRESS ): types.error_code;

PROCEDURE _os_ss_luopt ( arg0: types.path_id; arg1: types.u_int32;
			 arg2: SYSTEM.ADDRESS ): types.error_code;

PROCEDURE _os_ss_popt ( arg0: types.path_id; arg1: types.u_int32;
			arg2: SYSTEM.ADDRESS ): types.error_code;

PROCEDURE _os_ss_relea ( arg0: types.path_id ): types.error_code;

PROCEDURE _os_ss_rename ( arg0: types.path_id;
			  arg1: types.PtrSChar ): types.error_code;

PROCEDURE _os_ss_reset ( arg0: types.path_id ): types.error_code;

PROCEDURE _os_ss_sendsig ( arg0: types.path_id;
			   arg1: types.signal_code ): types.error_code;

PROCEDURE _os_ss_size ( arg0: types.path_id;
			arg1: types.u_int32 ): types.error_code;

PROCEDURE _os_ss_link_adj ( arg0: types.path_id; arg1: types.u_int32;
			    arg2: types.int32 ): types.error_code;

END sg_codes.
