Приложение Б

Нестандартные директивы препроцессора

Область действия описанных ниже нестандартных 
директив препроцессора распространяется на весь h-файл, 
в котором они встретились, не зависимо от их 
местоположения в этом файле. За исключением директив 
#module и #name, действие нестандартных директив не 
распространяется на файлы включенные посредством 
директивы #include. Действие директив #module и #name 
распространяется на все "include" файлы. Хотя 
нестандартные директивы препроцессора можно 
использовать в любых h-файлах, наиболее эффективно их 
использование в pre-header файле.


Б.1  Директива #merge 

Отменяет для отдельного файла действующую поддержку 
иерархии h-файлов (отдельный h-фйал в отдельный def-
модуль).

#merge <имя_файла>|"имя_файла"

Указанный в директиве h-файл не транслируется в 
отдельный def-модуль. Все def-модули, полученные из h-
файлов, в которых встречается данный файл в директиве 
#include, не импортируют его, а полученный из него 
модула-2 текст вставляют как часть своего модуля.

Например: имеется два h-файла m1.h и m2.h

/* m1.h */ 
  #merge <m2.h>
  typedef int Integer;
  #include <m2.h>
  RETVAL handler( int );
/* end m1.h */ 

/* m2.h */
  struct descriptor{
    Integer handdl;
  } desc;
  typedef int far * RETVAL;
/* end m2.h */

Из этих h-файлов будет порожден следующий модула-2 
текст:

(* m1.def *)
  TYPE 
    Integer = SYSTEM.int;
  (* ------------------------------------------ *)
  (*                   m2.h                     *)
  (* ------------------------------------------ *)
  descriptor = RECORD
      handl: Integer;
  END;
  VAR 
    desc: descriptor;
  TYPE 
    RETVAL = POINTER TO SYSTEM.int;
  (* ------------------------------------------ *)
  (*                   m1.h                     *)
  (* ------------------------------------------ *)
  PROCEDURE handler ( arg0: SYSTEM.int ): RETVAL;
(* end m1.def *)


Б.2  Директива #parameters

В языке Си нет возможности передавать параметр 
функции по ссылке, вместо этого передают указатель на 
этот параметр. Поэтому параметру Си функции, 
объявленному как указатель, в Модуле-2 соответствуют 
четыре различных объявления параметров. Так объявлению 
функции

void function( char * arg );

могут соответствовать следующие объявления в Модуле-2:

TYPE PtrChar = POINTER TO CHAR;
   
PROCEDURE function ( VAR arg: CHAR );
PROCEDURE function ( arg: ARRAY OF CHAR );
PROCEDURE function ( VAR arg: ARRAY OF CHAR );
PROCEDURE function ( arg: PtrChar );

Не имея информации о том, что делает процедура, 
нельзя сказать, какой из вариантов наиболее подходящий. 
По умолчанию в таких случаях для параметра используется 
тип указатель. Директива #parameterers позволяет для 
конкретной функции явно указать, какой из вариантов 
генерации нужно выбрать. Синтаксис директивы: 

#parameters 
   { имя_функции ( число ) : ( VAR | ARRAY |
     VAR ARRAY ) ; }
#end 

Число является номером аргумента функции, для 
которого указывается вариант генерации. Для Си функции 
все варианты эквивалентны. По умолчанию всегда 
используется один и тот же вариант, так что 
пользователю придется вносить изменения чтобы избежать 
явного преобразования типов, которое приводит к 
отключению контроля типов.


Б.3  Директива #bitset

Часто переменные и константы типа unsigned long int 
используются как набор битов. Таким образом объявлению

#define mask 0x22u
unsigned long int mask2;

В Модуле-2 могут соответствовать два объявления:

CONST mask = 22H;
VAR   mask2: LONGCARD;

и

CONST  mask = {1, 5};
VAR    mask2: BITSET;

Директива #bitset указывает для переменных и констант 
типа unsigned long int какой из вариантов использовать.

#bitset
  "unsigned" ";" | Designator ";" { Designator ";" }
#end

В данном случае unsigned означает, что тип unsigned 
long int всегда будет транслироваться в BITSET и 
константы этого типа всегда будут транслироваться в 
константы типа BITSET. Если вместо unsigned 
используется список из Designator, то только объекты, 
указанные в этом списке, будут транслироваться в 
объекты типа BITSET.

Designator = identifier { "^" | "." identifier | 
             "(" number ")" | "[" "]" }

где

"^"            означает разыменование указателя,
"." ientifier  означает поле структуры или
               объединения,
"(" number ")" означает аргумент функции c
               порядковым номером number (аргументы
               нумеруются с нуля)
"[" "]"        означает элемент массива.

На пример, следующий С текст

#bitset
  s.field;
  UINT;
  variable;
  function;
  function(0);
  array[];
  constant;
#end

struct s{
  unsigned long int field;
};

typedef unsigned long int UINT;

unsigned long int variable;

unsigned long int function(unsigned long int
                           argument);

unsigned long int array[10];

#define constant 0x11u

транслируется в следующий модула-2 текст

TYPE
  s = RECORD
    field: BITSET;
  END;
  UINT = BITSET;
VAR 
  variable: BITSET;
PROCEDURE function ( argument: BITSET ): BITSET;
VAR 
  array: ARRAY [0..9] OF BITSET;
CONST 
  constant = {0, 4};


Б.4  Директива #module

Как было замечено вначале, наиболее эффективно 
использовать нестандартные директивы в pre-header 
файле. Директива #module позволяет выделить часть Си 
текста и указать h-файл, к которому он относится.

  #module имя_файла
    Си текст 
  #final
    Си текст
  #end

В директиве задается имя файла, к которому относится 
Си текст, заключенный между директивами #module и #end. 
Этот текст вставляется в начало указанного h-файла. 
Альтернатива #final не обязательна. Если она 
присутствует, то Си текст заключенный между директивами 
#module и #final, вставляется в начало указанного h-
файла, а между #final и #end - в конец этого h-файла.


Б.5  Директива #name

В языке Си имена h-файлов не являются 
идентификаторами, т.е. на имя h-файла не 
распространяются соглашения о идентификаторах. Имена h-
файлов могут содержать недопустимые для идентификаторов 
символы. Поскольку в Модуле-2 имена модулей являются 
идентификаторами, то для использования таких h-файлов 
их необходимо переименовать. 

#name ( <file_name> | "file_name" ) identifier

Указанное в директиве имя файла при трансляции везде 
в def-модулях будет заменяться на identifier. Если эту 
директиву указать в pre-header файле, то совсем нет 
необходимости просматривать и исправлять все исходные 
h-файлы с этой целью.


Б.6  Директива #end

Нестандартные директивы препроцессора #module, 
#parameters и #bitset должны заканчиваться этой 
директивой.
