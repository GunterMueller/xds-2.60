\chapter{\XDS{} Оберон-2}\label{o2}
\index{Оберон-2}

В этой главе описаны детали языка
\ot{}, специфические для данной реализации. В стандартном режиме
\footnote{Когда выключены опции \OERef{O2EXTENSIONS} и \OERef{O2NUMEXT}} 
\xds{} \ot{} полностью совместим с компиляторами ETH
(см. {\em The Оберон-2 Report}). 
Последние изменения в языке описаны в % !!!
\ref{o2:changes}.

Чтобы обеспечить плавный переход от Модулы-2 к Оберону-2,
\XDS{} позволяет использовать в Оберон-2 модулях все типы данных
из Модулы-2 (см. \ref{o2:usingm2}).

Реализованы также некоторые расширения языка, предложенные в
{\em The Oakwood Guidelines for the Оберон-2 Compiler Developers}
(Оуквудские Рекомендации разработчикам компиляторов с Оберона-2)
\footnote{Эти рекомендации были составлены группой разработчиков,
включая разработчиков из ETH,
после совещания в Оуквуд Отеле, Кройдон, Великобритания, в июне 1993 г.}
(см. \ref{o2:oakext}). 
Остальные расширения описаны в \ref{o2:ext}. 
Поскольку \xds{} --- мнгогоязыковая система в полном смысле слова,
введены также некоторые средства для интерфейса с другими языками
(см. Главу \ref{multilang}).

\section{Среда программирования для Оберона}\label{o2:env}
\index{Среда программирования для Оберона}

Язык \ot{} был первоначально предназначен для использования в среде
предоставляющей возможности
{\em активации команд, сборки мусора} \index{сборка мусора} и 
{\em динамической загрузки} модулей. Не являясь частью языка, все
эти средства, тем не менее, повышают мощность Оберона-2.

Сборщик мусора и активация команд реализованы в 
Системе Поддержки Исполнения Оберона
и могут быть использованы в любой программе. Динамический загрузчик
не входит в настоящую версию. См. подробнее в
\ref{rts:oberonRTS}.

\subsection{Структура программы}\label{o2:env:main}

В системе программирования для Оберона-2, любая описанная 
процедура без параметров может рассматриваться как основная программа
и вызываться по ее имени (квалифицированный идентификатор вида
\verb|ModuleName.ProcName|).

Поскольку \xds{} не содержит специальной Оберон-системы, и по
другим причинам, в нем для объявления программных модулей, 
или модулей верхнего уровня, выбран другой подход.

Модуль верхнего уровня Вашей программы должен быть объявлен таковым
путем трансляции его с выставленной опцией 
{\bf MAIN}. При этом генерируется точка входа программы.
Только один модуль программы может быть скомпилирован с этой опцией.

\subsection{Создание определяющего модуля}\label{o2:env:makedef}
\index{Оберон-2!определяющий модуль}
\index{определяющий модуль Оберон-2 модуля}

\xds{} предоставляет два различных способа создания определяющего
модуля для Оберон-2 модуля:
\begin{itemize}
\item
в режиме {\bf BROWSE} компилятор генерирует определяющий модуль
по символьному файлу (см. \ref{xc:modes:browse});
\item
опция \OERef{MAKEDEF} заставляет Оберон-компилятор после
успешной компиляции породить псевдо-определяющий модуль.
\end{itemize}

Опция \OERef{MAKEDEF} предоставляет дополнительные возможности:
компилятор сохранит так называемые 
{\em экспортируемые} комментарии (т.е. комментарии, начинающиеся с
`(**'), если выставлена также опция
\OERef{XCOMMENTS}.

Генерируемый псевдо-определяющий модуль содержит все экспортируемые
описания в порядке их появления в исходном тексте. Экспортируемые 
комментарии при этом помещаются в подходящие позиции.

Определяющий модуль может порождаться в трех
{\em стилях}.\index{стиль просмотра}
Параметр \OERef{BSTYLE} служит для выбора одного из них:
{\bf DEF} (по умолчанию), {\bf DOC} или {\bf MOD}.

\begin{description}
\item[Стиль DEF] \mbox{}

Генерируется определяющий модуль в стиле ETH. Все
{\em процедуры, связанные с типом} ({\em методы}) и относящиеся 
к ним комментарии при этом указываются как часть соответствующего 
типа записи.

Это --- единственный стиль, в котором применимы опции 
\OERef{BSREDEFINE} и \OERef{BSCLOSURE}.

\item[Стиль DOC] \mbox{}

В этом стиле описания методов (без комментариев) включаются в описание
типа записи, а также сохраняются в тех местах, где они находятся в
исходном тексте.

\item[Стиль MOD] \mbox{}

В этом стиле генерируется файл, который после небольшой модификации
может быть скомпилирован как Оберон-модуль (например, он будет содержать
строки "END procname" и~т.п.)
\end{description}

\section{Последние изменения в языке}\label{o2:changes}

\subsection{ASSERT}\label{o2:ASSERT}\index{ASSERT (Оберон-2)}
\index{Оберон-2!ASSERT}

Процедура ASSERT проверяет значение своего булевского параметра
и прекращает выполнение программы, если он не равен
TRUE. Второй, необязательный, параметр задает
{\em код остановки задачи}. Если он опущен, подставляется стандартное
значение.

\begin{verbatim}
PROCEDURE ASSERT(cond: BOOLEAN [; code: INTEGER]);
\end{verbatim}

Вызов \verb|ASSERT(expr,code)| эквивалентен
\begin{verbatim}
IF NOT expr THEN HALT(code) END;
\end{verbatim}

\subsection{Подчерки в идентификаторах}
\index{Оберон-2!identifiers}

В соответствии с {\em Оуквудскими Рекомендациями}, символ подчерка "\_" 
можно использовать в идентификаторах как букву.
\begin{verbatim}
ident = ( letter | "_" ) { letter | digit | "_" }.
\end{verbatim}
Мы рекомендуем использовать его с осторожностью, поскольку
это может привести к проблемам при переносе программ на другие
компиляторы. Эта черта языка существенна для интерфейса с другими
языками (см. Главу \ref{multilang}).

\subsection{Прагмы в исходном тексте}\label{o2:pragmas}

Директивы в исходном тексте (или прагмы) служат для установки опций 
компилятора в исходном тексте и для выбора частей текста, которые нужно
компилировать (условная компиляция).
В соответствии с {\em Оуквудскими Рекомендациями} все прагмы содержатся
внутри псевдо-комментариев в стиле ISO \mt{}, использующих
угловые скобки \verb|<* ... *>|.

Эти дополнительные языковые конструкции не следует рассматривать как
часть языка \ot{}. 
Скорее, это отдельный язык контроля компиляции, сосуществующий
с языком \ot{}. 
Опция \OERef{O2ISOPRAGMA} позволяет использовать прагмы.

Синтаксис директив в языках \mt{} и
\ot{} одинаков. См. подробнее в \ref{m2:pragmas}.

\section{Оуквудские числовые расширения}\label{o2:oakext}
\index{Оуквудские расширения}
\index{Оберон-2!числовые расширения}

\xds{} \ot{} поддерживает два таких расширения, важных для 
научного программирования, а именно:
\begin{itemize}
\item комплексные числа
\item операция возведения в степень
\end{itemize}
Для пользования ими следует выставить опцию \OERef{O2NUMEXT}.

\subsection{Комплексные числа}\label{o2:oakext:complex}
\index{Оберон-2!комплексные числа}

\onumextonly{}

При выставленной опции \OERef{O2NUMEXT} в иерархию числовых типов включаются
два дополнительных типа:
\begin{center}
\begin{tabular}{lcl}
COMPLEX     & определен как & (REAL,REAL)          \\
LONGCOMPLEX & определен как & (LONGREAL,LONGREAL)  \\
\end{tabular}
\end{center}
Все числовые типы образуют (частичную) иерархию
$$
\mbox{LONGCOMPLEX} \subseteq
\begin{array}{l}
\mbox{COMPLEX}  \\
\mbox{LONGREAL} \\
\end{array}
\subseteq \mbox{REAL} \subset \mbox{\em целые типы}
$$
Для комплексных констант используется обычная математическая нотация:
\begin{verbatim}
number = integer | real | complex.
complex = real "i".
\end{verbatim}
Например, константа $5.0i$ обозначает комплексное число с 
вещественной частью, равной нулю, и мнимой частью $5.0$. 
Комплексные константы с ненулевой вещественной частью могут быть
заданы с помощью арифметических операций.
\begin{verbatim}
CONST
  i = 1.i;
  x = 1. + 1.i;
\end{verbatim}
Для описаний переменных
\begin{verbatim}
VAR
  c: COMPLEX;
  l: LONGCOMPLEX;
  r: REAL;
  x: INTEGER;
\end{verbatim}
следующие операторы разрешены:
\begin{verbatim}
  c:=i+r;
  l:=c;
  l:=c*r;
  l:=l*c;
\end{verbatim}

Новые функции преобразования {\tt RE} и {\tt IM} служат для получения
вещественной и мнимой части комплексного числа. Обе функции имеют 
один параметр. 
Если параметр типа COMPLEX, то обе функции возвращают значение типа
REAL; если параметр типа LONGCOMPLEX,
то функции возвращают значение типа LONGREAL;
иначе параметр должен быть комплексной константой, и возвращаются
вещественные константы.

Комплексное значение можно сформировать, применив 
стандартную функцию {\tt CMPLX} к двум вещественным.
Если оба аргумента {\tt CMPLX} --- вещественные константы, то 
результат --- комплексная константа.

\begin{verbatim}
CONST i = CMPLX(0.0,1.0);
\end{verbatim}

Если оба выражения имеют тип REAL,
то функция возвращает значение типа COMPLEX,
иначе --- типа LONGCOMPLEX.

\subsection{Операция возведения в степень}
\index{Оберон-2!возведение в степень}

\onumextonly{}

Знак возведения в степень {\tt **} позволяет обычную 
(без вызовов функций)
запись арифметических выражений с этой операцией.
Приоритет этой операции выше, чем у мультипликативных операций.
\begin{verbatim}
Term     =  Exponent { MulOp Exponent }.
Exponent =  Factor { "**" Factor }.
\end{verbatim}
{\bf Замечание:} Возведение в степень право-ассоциативно:
$$
  a**b**c \mbox{ вычисляется как } a**(b**c)
$$

Левый операнд у возведения в степень ({\tt a**b}) 
может быть любого числового типа (включая комплексные), а правый
операнд должен быть вещественного или целочисленного типа. Тип 
результата не зависит от типа правого операнда и определяется в 
соответствии с таблицей:
\begin{center}
\begin{tabular}{|l|l|} \hline
\bf Тип левого операнда & \bf Тип результата \\ \hline
целый тип       & REAL \\
REAL            & REAL \\
LONGREAL        & LONGREAL \\
COMPLEX         & COMPLEX \\
LONGCOMPLEX     & LONGCOMPLEX \\
\hline
\end{tabular}
\end{center}

\section{Конструкции из Модулы-2}\label{o2:usingm2}
\index{Оберон-2!конструкции Модулы-2}

Все типы языка \mt{} и соответствующие операции можно использовать
в Обероне-2, включая: перечислимые типы, отрезки, вариантные записи,
множества, и~т.д.

\paragraph{Важные замечания:}
\begin{itemize}
\item Не разрешается описывать в Оберон-2 модуле модуловские типы.
\item Модуль, использующий конструкции из Модулы-2, может быть 
не переносима другие компиляторы.
\end{itemize}

\Example
\begin{verbatim}
(*MODULA-2*) DEFINITION MODULE UsefulTypes;

TYPE
  TranslationTable = ARRAY CHAR OF CHAR;
  Color  = (red,green,blue);
  Colors = SET OF Color;

END UsefulTypes.

(*Оберон-2*) MODULE UsingM2;

IMPORT UsefulTypes;

TYPE
  TranslationTable* = UsefulTypes.TranslationTable;

VAR colors*: UsefulTypes.Color;

BEGIN
  colors:=UsefulTypes.Colors{UsefulTypes.red};
END UsingM2.
\end{verbatim}

\section{Расширения языка}\label{o2:ext}
\index{Оберон-2!расширения языка}

{\bf ПРЕДУПРЕЖДЕНИЕ:} Использование языковых расширений может привести 
к проблемам при переносе программ на другие компиляторы.

В стандартном режиме \xds{} \ot{} компилятор полностью совместим с
с компиляторами ETH (см. также \ref{o2:changes}).
Опция \OERef{O2EXTENSIONS} включает некоторые расширения языка.
Основные цели этих расширений:
\begin{itemize}
\item облегчить интерфейс с другими языками
     (см. Главу \ref{multilang}).
\item обеспечить обратную совместимость с прежними версиями \xds{}.
\end{itemize}

\Seealso
\begin{itemize}
\item         Директивы в исходном тексте (\ref{o2:pragmas})
\item         Оуквудские числовые расширения (\ref{o2:oakext}).
\end{itemize}

\subsection{Комментарии}
\index{Оберон-2!комментарии}

\oextonly

Наряду с \verb|(**)| вводится еще один формат для комментариев
в тексте программы. Часть строки от
``\verb|--|'' до конца строки рассматривается как комментарий.

\Example
\begin{verbatim}
VAR j: INTEGER; -- this is a comment
\end{verbatim}

\subsection{Конкатенация строк}
\index{конкатенация строк}
\index{Оберон-2!конкатенация строк}

\oextonly

Символ "+" можно использовать для конкатенации константных строк
и отдельных литер. Подробнее см. в
\ref{m2:ISO:strings}.

\subsection{Функция VAL}
\index{Оберон-2!VAL}\index{VAL (O2)}

\oextonly

Функция VAL служит для получения значения заданного скалярного типа
из выражения скалярного типа. Подробнее см. \ref{m2:ISO:conv}.
\begin{verbatim}
PROCEDURE VAL(Type; expr: ScalarType): Type;
\end{verbatim}

Функция VAL может применяться к любому скалярному типу,
включая системные типы фиксированного размера
(см. \ref{o2:fixed:size}).

\subsection{Параметры по чтению}
\index{параметры по чтению}
\index{Оберон-2!параметры по чтению}

\oextonly

В секции формальных параметров после имени параметра по значению
может стоять символ \verb|"-"|. Такой параметр называется
{\em параметром по чтению}; его значение не может изменяться в 
теле процедуры.
Параметры по чтению не нужно копировать перед активацией процедуры;
это повышает эффективность вызовов процедур со структурными
параметрами.
Параметры по чтению нельзя использовать в описании процедурного типа.

Мы рекомендуем использовать параметры по чтению с осторожностью.
Компилятор не отслеживает их изменений через другой параметр
или через глобальную переменную.

\Example
\begin{verbatim}
PROCEDURE Foo(VAR dest: ARRAY OF CHAR;
               source-: ARRAY OF CHAR);
BEGIN
  dest[0]:='a';
  dest[1]:=source[0];
END Foo;
\end{verbatim}

Вызов \verb|Foo(x,x)| приведет к неверному результату, поскольку
первый оператор изменяет значение
\verb|source[0]| (\verb|source| не копируется, и находится в том же месте
в памяти, что и \verb|dest|).

\subsection{Переменное число параметров}
\index{SEQ параметры}
\index{Оберон-2!SEQ параметры}

\oextonly

Все, что сказано в \ref{m2:SEQ:param}, применимо также к
Оберону-2.

\subsection{Конструкторы}
\index{Конструкторы}
\index{Оберон-2!конструкторы}

\oextonly

Все, что сказано в \ref{m2:ISO:aggregates}, применимо также к Оберону-2.

\section{Оберон-2 модуль SYSTEM}
\label{o2:system}
\index{Оберон-2!модуль SYSTEM}
\index{системные модули!SYSTEM (O2)}
\index{SYSTEM@{\bf SYSTEM}}

Модуль SYSTEM предоставляет средства низкого уровня. 
Этот модуль не существует в том же смысле, что обычные библиотеки:
он вшит в сам компилятор. Однако, чтобы получить доступ к его
средствам, идентификаторы должны быть импортированы обычным образом.

Некоторые процедуры модуля SYSTEM являются генерическими, и не могут
быть обычным образом декларированы; например, они могут быть применимы 
ко многим различным типам операндов.

\xds{} \ot{} компилятор реализует все системные средства, описанные в
{\em Сообщении об Обероне-2} (кроме GETREG, PUTREG и CC) и       % !!!
позволяет также пользоваться всеми средствами, описанными в
Международном стандарте языка
\mt{} (см. \ref{m2:ISO:system}). 
В этом разделе мы опишем только средства, 
специфические для данной реализации.
\index{SYSTEM!GETREG}
\index{SYSTEM!PUTREG}

\subsection{Совместимость с типом BYTE}
\index{Оберон-2!SYSTEM.BYTE}

Выражения типов CHAR, BOOLEAN, SHORTINT и SYSTEM.CARD8 
можно присваивать переменным типа
BYTE или передавать как фактические параметры в формальные параметры типа
BYTE.

%??? formal variable parameter
Если формальный VAR-параметр имеет тип ARRAY OF BYTE,
то соответствующий фактический параметр может быть любого типа,
кроме числовой константы.

\subsection{Целые системные типы}\label{o2:fixed:size}

Модуль SYSTEM содержит знаковые типы
INT8, INT16, INT32
и беззнаковые типы CARD8, CARD16, CARD32,
размер которых всегда равен
8, 16 или 32 битам соответственно. Эти типы введены для 
облегчения интерфейса с библиотеками на других языках
(см. Главу \ref{multilang}).
Основные типы SHORTINT, INTEGER, LONGINT
--- это синонимы типов INT8, INT16 и INT32 соответственно.

Беззнаковые типы образуют иерархию, в которой больший тип
включает все значения меньших типов.
$$
\mbox{SYSTEM.CARD32} \supseteq \mbox{SYSTEM.CARD16} \supseteq \mbox{SYSTEM.CARD8}
$$
Иерархия всех числовых типов такова (см. также \ref{o2:oakext:complex}):
$$
\mbox{LONGREAL} \supseteq \mbox{REAL} \supseteq
\left \{
  \begin{array}{l}
     \mbox{signed types}        \\
     \mbox{unsigned types}      \\
  \end{array}
\right .
$$

\subsection{NEW и DISPOSE}\label{o2:system:new}
\index{SYSTEM!NEW}
\index{SYSTEM!DISPOSE}
\index{NEW (SYSTEM, O2)}
\index{DISPOSE (SYSTEM, O2)}

Процедура {\tt SYSTEM.NEW} служит для аллокации системной памяти,
т.е. памяти, на которой не происходит сборка мусора.
{\tt SYSTEM.NEW} --- генерическая процедура, применяемая к указателям,
и может быть использована по-разному, в зависимости от базового типа 
указателя.

{\small
\begin{verbatim}
PROCEDURE NEW(VAR p: AnyPointer [; x0,..xn: integer]);
\end{verbatim}
}

Пусть \verb|P| описано как \mbox{{\tt POINTER TO} $T$} и
$p$ --- типа $T$.
\begin{center}
\begin{tabular}{lp{7.5cm}}
NEW($p$)       &  $T$ --- тип записи или массива фиксированного размера.
Процедура аллоцирует участок памяти в SIZE($p$\^) байт и присваивает
$p$ его адрес.          \\

NEW($p$,$n$)   &  $T$ --- тип записи или массива фиксированного размера.
Процедура аллоцирует участок памяти в $n$ байт и присваивает
$p$ его адрес.          \\
NEW($p$,$x_0$,..$x_{n-1}$) & $T$ --- $n$-мерный открытый массив
Процедура аллоцирует участок памяти для открытого массива с размерами,
заданными выражениями $x_0$,..$x_{n-1}$     \\
\end{tabular}
\end{center}

Процедура {\tt SYSTEM.DISPOSE} служит для освобождения памяти,
аллоцированной с помощью {\tt SYSTEM.NEW}.
Она не деаллоцирует блок немедленно, а помечает его как свободный.
Впоследствии он будет деаллоцирован при следующем вызове сборщика мусора.
%??? 

{\small
\begin{verbatim}
PROCEDURE DISPOSE(VAR p: AnyPointer; [size: integer]);
\end{verbatim}
}

\begin{center}
\begin{tabular}{lp{7.5cm}}
DISPOSE($p$)    & $T$ --- тип записи или массива.
Процедура освобождает участок памяти соответствующего размера. \\
DISPOSE($p$,$n$) & $T$ --- тип записи или массива фиксированного размера.
Процедура освобождает участок памяти размером $n$ байт. \\
\end{tabular}
\end{center}

\subsection{M2ADR}\label{o2:system:m2adr}
\index{SYSTEM!M2ADR}
\index{M2ADR (SYSTEM, O2)}

Функция SYSTEM.ADR() в Обероне возвращает значение типа LONGINT,
что не всегда удобно.
Функция {\tt SYSTEM.M2ADR} ведет себя как
{\tt SYSTEM.ADR} в Модуле-2, возвращая {\tt SYSTEM.ADDRESS}:  % !!! ref

PROCEDURE M2ADR(VAR x: any type): ADDRESS;



