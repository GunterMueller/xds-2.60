(* regppc.def  Mar 4  14:9:15  2000 *)
(* Generated by H2D v1.31.0 from regppc.h. *)
<*+ M2ADDTYPES *>
<*+ M2EXTENSIONS *>
<*+ NOHEADER *> 
<* IF NOT DEFINED(GENTYPEDEF) THEN *> <* NEW GENTYPEDEF+ *> <* END *>

DEFINITION MODULE ["C"] regppc;

IMPORT types, SYSTEM;

(* H2D:  Required IMPORT clause: 
IMPORT regppc, types;
*)

CONST 

<* IF DEFINED(_MPFPPC603) THEN *>
(*  MSR - Machine State Register  *)


  MSR_POW = 40000H;   (*  power management enable bit  *)
  MSR_TGPR = 20000H;   (*  temporary GPR mapping  *)
  MSR_ILE = 10000H;   (*  exception little-endian mode  *)
  MSR_FE0 = 800H;   (*  floating-point exception mode 0 bit  *)
  MSR_SE = 400H;   (*  single-step trace enable bit  *)
  MSR_BE = 200H;   (*  branch trace enable bit  *)
  MSR_FE1 = 100H;   (*  floating-point exception mode 1 bit  *)
  MSR_IP = 40H;   (*  exception prefix enable bit  *)
  MSR_IR = 20H;   (*  instruction address translation enable bit  *)
  MSR_DR = 10H;   (*  data address translation enable bit  *)
  MSR_RI = 2H;   (*  recoverable exception indicator bit  *)
  MSR_LE = 1H;   (*  little-endian enable bit  *)
  MSR_FP = 2000H;   (*  floating-point enable bit  *)

CONST 
  MSR_EE = 8000H;   (*  external exception (IRQ) enable bit  *)

CONST 
  MSR_PR = 4000H;   (*  privilege Level bit  *)

CONST 
  MSR_ME = 1000H;   (*  machine check enable bit  *)

(*  HID0 - Hardware Implementation Register 0  *)

CONST 
  HID0_EMCP = 80000000H;   (*  enable machine check pin  *)
  HID0_EBA = 20000000H;   (*  enable bus address parity checking  *)
  HID0_EBD = 10000000H;   (*  enable bus data parity checking  *)
  HID0_SBCLK = 8000000H;   (*  select bus clock for test clock pin  *)
  HID0_EICE = 4000000H;   (*  enable ICE outputs  *)
  HID0_ECLK = 2000000H;   (*  enable external test clock pin  *)
  HID0_PAR = 1000000H;   (*  disable precharge of ARTRY and shared pins  *)
  HID0_DOZE = 800000H;   (*  doze mode: PLL, time base, snooping active  *)
  HID0_NAP = 400000H;   (*  nap mode: PLL and time base active  *)
  HID0_SLEEP = 200000H;   (*  sleep mode: no external clock required  *)
  HID0_DPM = 100000H;   (*  enable dynamic power management  *)
  HID0_ICE = 8000H;   (*  instruction cache enable  *)
  HID0_DCE = 4000H;   (*  data cache enable  *)
  HID0_ILOCK = 2000H;   (*  instruction cache lock  *)
  HID0_DLOCK = 1000H;   (*  data cache lock  *)
  HID0_ICFI = 800H;   (*  instruction cache flash invalidate  *)
  HID0_DCI = 400H;   (*  data cache flash invalidate  *)
  HID0_FBIOB = 10H;   (*  force branch indirect on bus  *)
  HID0_NOOPTI = 1H;   (*  no-op touch instructions  *)

CONST 
  BATU_BEPI = 0FFFE0000H;   (*  block logical page index field  *)
  BATU_BL = 1FFCH;   (*  block length field  *)
  BATU_VS = 2H;   (*  supervisor mode valid bit  *)
  BATU_VP = 1H;   (*  user mode valid bit  *)

CONST 
  BATL_BRPN = 0FFFE0000H;   (*  physical block number  *)
  BATL_W = 40H;   (*  write-through cache mode  *)
  BATL_I = 20H;   (*  caching inhibited cache mode  *)
  BATL_M = 10H;   (*  memory coherency cache mode  *)
  BATL_G = 8H;   (*  guarded cache mode (DBATs only)  *)
  BATL_R = 1H;   (*  read only access mode  *)
  BATL_RW = 2H;   (*  read/write access mode  *)

CONST 
  SEG_T = 80000000H;   (*  I/O controller interface translation  *)
  SEG_KS = 40000000H;   (*  Supervisor-state protection key  *)
  SEG_KP = 20000000H;   (*  User-state protection key  *)
  SEG_N = 10000000H;   (*  No-execute protection bit  *)
  SEG_VSID = 0FFFFFFH;   (*  Virtual segment ID  *)

(*  Page Table Entry definitions (PTE)  *)
(*  Word zero PTE definitions  *)

CONST 
  PTE0_V = 80000000H;   (*  valid entry bit  *)
  PTE0_VSID = 7FFFFF80H;   (*  vitual segment ID  *)
  PTE0_H = 40H;   (*  hash function identifier  *)
  PTE0_API = 3FH;   (*  abbreviated page index  *)

(*  Word one definitions  *)

CONST 
  PTE1_PPN = 0FFFFF000H;   (*  physical page number  *)
  PTE1_RF = 100H;   (*  reference indicator bit  *)
  PTE1_C = 80H;   (*  changed indicator bit  *)
  PTE1_W = 40H;   (*  write-through cache mode  *)
  PTE1_I = 20H;   (*  caching inhibited cache mode  *)
  PTE1_M = 10H;   (*  memory coherency cache mode  *)
  PTE1_G = 8H;   (*  guarded cache mode  *)
  PTE1_R = 1H;   (*  read only access mode  *)
  PTE1_RW = 2H;   (*  read/write access mode  *)

<* END *>

<*IF DEFINED(_MPFPPC604) THEN*>
(*  MSR - Machine State Register  *)

CONST 
  MSR_POW = 40000H;   (*  power management enable bit  *)
  MSR_TGPR = 20000H;   (*  temporary GPR mapping  *)
  MSR_ILE = 10000H;   (*  exception little-endian mode  *)
  MSR_FE0 = 800H;   (*  floating-point exception mode 0 bit  *)
  MSR_SE = 400H;   (*  single-step trace enable bit  *)
  MSR_BE = 200H;   (*  branch trace enable bit  *)
  MSR_FE1 = 100H;   (*  floating-point exception mode 1 bit  *)
  MSR_IP = 40H;   (*  exception prefix enable bit  *)
  MSR_IR = 20H;   (*  instruction address translation enable bit  *)
  MSR_DR = 10H;   (*  data address translation enable bit  *)
  MSR_RI = 2H;   (*  recoverable exception indicator bit  *)
  MSR_LE = 1H;   (*  little-endian enable bit  *)
  MSR_FP = 2000H;   (*  floating-point enable bit  *)

CONST 
  MSR_EE = 8000H;   (*  external exception (IRQ) enable bit  *)

CONST 
  MSR_PR = 4000H;   (*  privilege Level bit  *)

CONST 
  MSR_ME = 1000H;   (*  machine check enable bit  *)

CONST 
  HID0_EMCP = 80000000H;   (*  enable machine check pin  *)
  HID0_EBC = 40000000H;   (*  enable cache parity checking  *)
  HID0_EBA = 20000000H;   (*  enable bus address parity checking  *)
  HID0_EBD = 10000000H;   (*  enable bus data parity checking  *)
  HID0_PAR = 1000000H;   (*  disable precharge of ARTRY and shared pins  *)
  HID0_ICE = 8000H;   (*  instruction cache enable  *)
  HID0_DCE = 4000H;   (*  data cache enable  *)
  HID0_ILOCK = 2000H;   (*  instruction cache lock  *)
  HID0_DLOCK = 1000H;   (*  data cache lock  *)
  HID0_ICFI = 800H;   (*  instruction cache flash invalidate  *)
  HID0_DCI = 400H;   (*  data cache flash invalidate  *)
  HID0_SIE = 80H;   (*  serial instruction execution disable  *)
  HID0_BHT = 4H;   (*  branch history table enable  *)

(*  BAT - Upper Block Address Translation Register  *)

CONST 
  BATU_BEPI = 0FFFE0000H;   (*  block logical page index field  *)
  BATU_BL = 1FFCH;   (*  block length field  *)
  BATU_VS = 2H;   (*  supervisor mode valid bit  *)
  BATU_VP = 1H;   (*  user mode valid bit  *)

CONST 
  BATL_BRPN = 0FFFE0000H;   (*  physical block number  *)
  BATL_W = 40H;   (*  write-through cache mode  *)
  BATL_I = 20H;   (*  caching inhibited cache mode  *)
  BATL_M = 10H;   (*  memory coherency cache mode  *)
  BATL_G = 8H;   (*  guarded cache mode (DBATs only)  *)
  BATL_R = 1H;   (*  read only access mode  *)
  BATL_RW = 2H;   (*  read/write access mode  *)

(*  Segment Register definitions  *)

CONST 
  SEG_T = 80000000H;   (*  I/O controller interface translation  *)
  SEG_KS = 40000000H;   (*  Supervisor-state protection key  *)
  SEG_KP = 20000000H;   (*  User-state protection key  *)
  SEG_N = 10000000H;   (*  No-execute protection bit  *)
  SEG_VSID = 0FFFFFFH;   (*  Virtual segment ID  *)

(*  Page Table Entry definitions (PTE)  *)
(*  Word zero PTE definitions  *)

CONST 
  PTE0_V = 80000000H;   (*  valid entry bit  *)
  PTE0_VSID = 7FFFFF80H;   (*  vitual segment ID  *)
  PTE0_H = 40H;   (*  hash function identifier  *)
  PTE0_API = 3FH;   (*  abbreviated page index  *)

(*  Word one definitions  *)

CONST 
  PTE1_PPN = 0FFFFF000H;   (*  physical page number  *)
  PTE1_RF = 100H;   (*  reference indicator bit  *)
  PTE1_C = 80H;   (*  changed indicator bit  *)
  PTE1_W = 40H;   (*  write-through cache mode  *)
  PTE1_I = 20H;   (*  caching inhibited cache mode  *)
  PTE1_M = 10H;   (*  memory coherency cache mode  *)
  PTE1_G = 8H;   (*  guarded cache mode  *)
  PTE1_R = 1H;   (*  read only access mode  *)
  PTE1_RW = 2H;   (*  read/write access mode  *)
<* END *>

<* IF DEFINED(_MPFPPC821) THEN*>
(*  MSR - Machine State Register  *)
CONST 
  MSR_POW = 40000H;   (*  power management enable bit  *)
  MSR_TGPR = 20000H;   (*  temporary GPR mapping  *)
  MSR_ILE = 10000H;   (*  exception little-endian mode  *)
  MSR_EE = 8000H;   (*  external exception (IRQ) enable bit  *)
  MSR_PR = 4000H;   (*  privilege Level bit  *)
  MSR_FP = 2000H;   (*  floating-point enable bit  *)
  MSR_ME = 1000H;   (*  machine check enable bit  *)
  MSR_FE0 = 800H;   (*  floating-point exception mode 0 bit  *)
  MSR_SE = 400H;   (*  single-step trace enable bit  *)
  MSR_BE = 200H;   (*  branch trace enable bit  *)
  MSR_FE1 = 100H;   (*  floating-point exception mode 1 bit  *)
  MSR_IP = 40H;   (*  exception prefix enable bit  *)
  MSR_IR = 20H;   (*  instruction address translation enable bit  *)
  MSR_DR = 10H;   (*  data address translation enable bit  *)
  MSR_RI = 2H;   (*  recoverable exception indicator bit  *)
  MSR_LE = 1H;   (*  little-endian enable bit  *)

(*  Word one definitions  *)

CONST 
  PTE1_PPN = 0FFFFF000H;   (*  physical page number  *)
  PTE1_RF = 100H;   (*  reference indicator bit  *)
  PTE1_C = 80H;   (*  changed indicator bit  *)
  PTE1_W = 40H;   (*  write-through cache mode  *)
  PTE1_I = 20H;   (*  caching inhibited cache mode  *)
  PTE1_M = 10H;   (*  memory coherency cache mode  *)
  PTE1_G = 8H;   (*  guarded cache mode  *)
  PTE1_R = 1H;   (*  read only access mode  *)
  PTE1_RW = 2H;   (*  read/write access mode  *)

<*END*>


             (* end of reg*** files  *)


CONST 
  MSR_FP = 2000H;   (*  floating-point enable bit  *)

CONST 
  MSR_EE = 8000H;   (*  external exception (IRQ) enable bit  *)

CONST 
  MSR_PR = 4000H;   (*  privilege Level bit  *)
  USER_SR = MSR_PR;
                      (*  user state initial MSR value  *)

CONST 
  MSR_ME = 1000H;   (*  machine check enable bit  *)

(*  status register type declaration  *)

TYPE 
  status_reg = SYSTEM.unsigned;

(*  Define stack alignement mask for kernel  *)

CONST 
  ALIGN_STACK_MASK = 0FFFFFFFCH;   (*  4-byte alignment  *)

(*  Define some important instruction opcodes  *)

CONST 
  ILLEGAL = 0;   (*  define illegal instruction opcode  *)
  TW_INSTR = 7FE00008H;   (*  define trap instruction opcode  *)
  BCTRL_INSTR = 4E800421H;   (*  define bctrl instruction opcode  *)
  PE_FPU = 80000000H;   (*  FPU exception bit  *)
  PE_ILLEGAL = 40000000H;   (*  Illegal instruction exception bit  *)
  PE_PRIV = 20000000H;   (*  Privileged instruction exception bit  *)
  PE_TRAP = 10000000H;   (*  Trap instruction exception bit  *)
  INTENAB = 8000H;   (*  IRQ enable bit  *)
  INTMASK = -32769;   (*  IRQ disable mask  *)
  SUPERVIS = 0;   (*  Supervisor mode  *)
  TRACE = 400H;   (*  Trace mode  *)

(*  macros for initializing the status register of a new process  *)

CONST 
  SYS_SR = 0;   (*  system state initial MSR value  *)

CONST 
  EXCEPT_SIZE = 256;   (*  number of entries in the exception table  *)

(*  Vector Number definitions  *)

CONST 
  T_RESET = 1H;   (*  Reset  *)
  T_MCHK = 2H;   (*  Machine check  *)
  MEMORY_EXCPT = T_MCHK;
                           (*  define memory exception  *)
  T_DATA = 3H;   (*  Data access  *)
  T_INSTR = 4H;   (*  Instruction access  *)
  T_IRQ = 5H;   (*  External interrupt  *)
  T_ALIGN = 6H;   (*  Alignment  *)
  T_PROG = 7H;   (*  Program: FPU, illegal instr, privileged instr, trap *)
  T_NOFPU = 8H;   (*  FPU unavailable  *)
  T_DEC = 9H;   (*  Decrementer  *)
  T_SCALL = 0CH;   (*  System call  *)
<* IF DEFINED(_MPFPPC603) THEN *>
  T_TRACE = 0DH;
  T_ITM   = 10H;
  T_DLTM  = 11H;
  T_DSTM  = 12H;
  T_IABP  = 13H;
  T_SMI   = 14H;
<*ELSE*>
  T_RUN = 20H;   (*  Run mode/trace  *)
  T_END = 0FFH;
  T_SIZE = 40H;
<*END*>
(*  F_STRAP handler identifier definitions  *)

CONST 
  STRAP_MACH = 0;   (*  Machine check vector 200  *)
  STRAP_DATA = 1;   (*  Data access vector 300  *)
  STRAP_INSTR = 2;   (*  Instruction access vector 400  *)
  STRAP_ALIGN = 3;   (*  Alignment vector 600  *)
  STRAP_FPU = 4;   (*  FPU exception vector 700  *)
  STRAP_ILL = 5;   (*  Illegal instruction exception vector 700  *)
  STRAP_PRIV = 6;   (*  Privileged instruction vector 700  *)
  STRAP_MAX = 15;   (*  Logical maximum user catchable exception  *)
  STRAP_MIN = 0;   (*  Logical minimum user catchable exception  *)
  TRAP_MIN = 0;   (*  Minimum user trap handler identifier  *)
  TRAP_MAX = 15;   (*  Maximum user trap handler identifier  *)
  TRAP_TTL = 16;   (*  Total number of user traps  *)

(*  FPU emulation structure definitions  *)

<*IF NOT DEFINED(_FPU_NEW) THEN *>
TYPE
  Fregs = SYSTEM.ADDRESS;
<*ELSE*>
<*IF  DEFINED(_FPU_SOFT) THEN *>
TYPE 
  fpu_regs = RECORD
    fpgpr: ARRAY [0..(32*2)-1] OF LONGCARD;
    fpscr: LONGCARD;
  END;

  Fpu_Regs = POINTER TO fpu_regs;

  fregs = fpu_regs;

  Fregs = Fpu_Regs;

  gen_regs = RECORD
    gpr : ARRAY [0..32-1] OF LONGCARD;
    xer : LONGCARD;
    lr  : LONGCARD;
    ctr : LONGCARD;
    cr  : LONGCARD;
    srr0: LONGCARD;
    srr1: LONGCARD;
  END;

  Gen_Regs = POINTER TO gen_regs;

  Fpu_Context = POINTER TO fpu_context;

  fpu_context = RECORD
    regs     : gen_regs;
    fpregs   : fpu_regs;
    next_used: Fpu_Context;
    next_free: Fpu_Context;
  END;

(* Type 'Fpu_Context' was declared here in the source file *)

  excpt_stack = RECORD
    space: ARRAY [0..3-1] OF LONGCARD;
    xer  : LONGCARD;
    ctr  : LONGCARD;
    cr   : LONGCARD;
    lr   : LONGCARD;
    srr0 : LONGCARD;
    srr1 : LONGCARD;
    r14  : LONGCARD;
    r13  : LONGCARD;
    r12  : LONGCARD;
    r11  : LONGCARD;
    r10  : LONGCARD;
    r9   : LONGCARD;
    r8   : LONGCARD;
    r7   : LONGCARD;
    r6   : LONGCARD;
    r5   : LONGCARD;
    r4   : LONGCARD;
    r3   : LONGCARD;
    r2   : LONGCARD;
    r1   : LONGCARD;
    r0   : LONGCARD;
  END;

  Excpt_Stack = POINTER TO excpt_stack;
<* END *>
(*  End of FPU emulation structure definitions  *)
(* #define Fpu_desc void* *)
(* #define fpu_desc void *)
<*IF DEFINED(_FPU_HARD) THEN *>
 TYPE 
  fpu_regs = RECORD
    f0   : ARRAY [0..2-1] OF types.u_int32;  (*  floating-point registers  *)
    f1   : ARRAY [0..2-1] OF types.u_int32;
    f2   : ARRAY [0..2-1] OF types.u_int32;
    f3   : ARRAY [0..2-1] OF types.u_int32;
    f4   : ARRAY [0..2-1] OF types.u_int32;
    f5   : ARRAY [0..2-1] OF types.u_int32;
    f6   : ARRAY [0..2-1] OF types.u_int32;
    f7   : ARRAY [0..2-1] OF types.u_int32;
    f8   : ARRAY [0..2-1] OF types.u_int32;
    f9   : ARRAY [0..2-1] OF types.u_int32;
    f10  : ARRAY [0..2-1] OF types.u_int32;
    f11  : ARRAY [0..2-1] OF types.u_int32;
    f12  : ARRAY [0..2-1] OF types.u_int32;
    f13  : ARRAY [0..2-1] OF types.u_int32;
    f14  : ARRAY [0..2-1] OF types.u_int32;
    f15  : ARRAY [0..2-1] OF types.u_int32;
    f16  : ARRAY [0..2-1] OF types.u_int32;
    f17  : ARRAY [0..2-1] OF types.u_int32;
    f18  : ARRAY [0..2-1] OF types.u_int32;
    f19  : ARRAY [0..2-1] OF types.u_int32;
    f20  : ARRAY [0..2-1] OF types.u_int32;
    f21  : ARRAY [0..2-1] OF types.u_int32;
    f22  : ARRAY [0..2-1] OF types.u_int32;
    f23  : ARRAY [0..2-1] OF types.u_int32;
    f24  : ARRAY [0..2-1] OF types.u_int32;
    f25  : ARRAY [0..2-1] OF types.u_int32;
    f26  : ARRAY [0..2-1] OF types.u_int32;
    f27  : ARRAY [0..2-1] OF types.u_int32;
    f28  : ARRAY [0..2-1] OF types.u_int32;
    f29  : ARRAY [0..2-1] OF types.u_int32;
    f30  : ARRAY [0..2-1] OF types.u_int32;
    f31  : ARRAY [0..2-1] OF types.u_int32;
    fpscr: types.u_int32;                    (*  floating-point status register  *)
  END;

  fregs = fpu_regs;

  Fregs = POINTER TO fpu_regs;


<*END*>
<*END*>  (* _FPU_NEW *)
  longstk = RECORD
    format: types.u_int32;  (*  stack format  *)
<*IF DEFINED(_FPU_HARD) THEN *>
    f0    : ARRAY [0..2-1] OF types.u_int32;  (*  floating-point registers  *)
    f1    : ARRAY [0..2-1] OF types.u_int32;
    f2    : ARRAY [0..2-1] OF types.u_int32;
    f3    : ARRAY [0..2-1] OF types.u_int32;
    f4    : ARRAY [0..2-1] OF types.u_int32;
    f5    : ARRAY [0..2-1] OF types.u_int32;
    f6    : ARRAY [0..2-1] OF types.u_int32;
    f7    : ARRAY [0..2-1] OF types.u_int32;
    f8    : ARRAY [0..2-1] OF types.u_int32;
    f9    : ARRAY [0..2-1] OF types.u_int32;
    f10   : ARRAY [0..2-1] OF types.u_int32;
    f11   : ARRAY [0..2-1] OF types.u_int32;
    f12   : ARRAY [0..2-1] OF types.u_int32;
    f13   : ARRAY [0..2-1] OF types.u_int32;
    f14   : ARRAY [0..2-1] OF types.u_int32;
    f15   : ARRAY [0..2-1] OF types.u_int32;
    f16   : ARRAY [0..2-1] OF types.u_int32;
    f17   : ARRAY [0..2-1] OF types.u_int32;
    f18   : ARRAY [0..2-1] OF types.u_int32;
    f19   : ARRAY [0..2-1] OF types.u_int32;
    f20   : ARRAY [0..2-1] OF types.u_int32;
    f21   : ARRAY [0..2-1] OF types.u_int32;
    f22   : ARRAY [0..2-1] OF types.u_int32;
    f23   : ARRAY [0..2-1] OF types.u_int32;
    f24   : ARRAY [0..2-1] OF types.u_int32;
    f25   : ARRAY [0..2-1] OF types.u_int32;
    f26   : ARRAY [0..2-1] OF types.u_int32;
    f27   : ARRAY [0..2-1] OF types.u_int32;
    f28   : ARRAY [0..2-1] OF types.u_int32;
    f29   : ARRAY [0..2-1] OF types.u_int32;
    f30   : ARRAY [0..2-1] OF types.u_int32;
    f31   : ARRAY [0..2-1] OF types.u_int32;
    fpscr : types.u_int32;                    (*  floating-point status register  *)
 
<* END *>
    
    r31   : types.u_int32;  (*  general purpose registers  *)
    r30   : types.u_int32;
    r29   : types.u_int32;
    r28   : types.u_int32;
    r27   : types.u_int32;
    r26   : types.u_int32;
    r25   : types.u_int32;
    r24   : types.u_int32;
    r23   : types.u_int32;
    r22   : types.u_int32;
    r21   : types.u_int32;
    r20   : types.u_int32;
    r19   : types.u_int32;
    r18   : types.u_int32;
    r17   : types.u_int32;
    r16   : types.u_int32;
    r15   : types.u_int32;
    xer   : types.u_int32;  (*  interger exception register  *)
    ctr   : types.u_int32;  (*  counter register  *)
    cr    : types.u_int32;  (*  condition code register  *)
    lr    : types.u_int32;  (*  link register  *)
    srr0  : types.u_int32;  (*  exception program counter  *)
    srr1  : types.u_int32;  (*  machine status register  *)
    r14   : types.u_int32;  (*  general purpose registers  *)
    r13   : types.u_int32;
    r12   : types.u_int32;
    r11   : types.u_int32;
    r10   : types.u_int32;
    r9    : types.u_int32;
    r8    : types.u_int32;
    r7    : types.u_int32;
    r6    : types.u_int32;
    r5    : types.u_int32;
    r4    : types.u_int32;
    r3    : types.u_int32;
    r2    : types.u_int32;
    r1    : types.u_int32;
    r0    : types.u_int32;
  END;

  regs = longstk;

  Regs = POINTER TO longstk;

  shortstk = RECORD
    format: types.u_int32;  (*  stack format  *)
    xer   : types.u_int32;  (*  integer exception register  *)
    ctr   : types.u_int32;  (*  counter register  *)
    cr    : types.u_int32;  (*  condition code register  *)
    lr    : types.u_int32;  (*  link register  *)
    srr0  : types.u_int32;  (*  exception program counter  *)
    srr1  : types.u_int32;  (*  machine status register  *)
    r14   : types.u_int32;
    r13   : types.u_int32;
    r12   : types.u_int32;
    r11   : types.u_int32;
    r10   : types.u_int32;
    r9    : types.u_int32;
    r8    : types.u_int32;
    r7    : types.u_int32;
    r6    : types.u_int32;
    r5    : types.u_int32;
    r4    : types.u_int32;
    r3    : types.u_int32;
    r2    : types.u_int32;
    r1    : types.u_int32;
    r0    : types.u_int32;
  END;

  sregs = shortstk;

  SRegs = POINTER TO shortstk;

(*  Stack size macros  *)
(* #define SHORT_STACK sizeof(sregs) *)
(* #define LONG_STACK sizeof(regs) *)

END regppc.
