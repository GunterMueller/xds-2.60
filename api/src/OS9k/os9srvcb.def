(* os9srvcb.def  Feb 29  11:10:2  2000 *)
(* Generated by H2D v1.31.0 from os9srvcb.h. *)
<*+ M2ADDTYPES *>
<*+ M2EXTENSIONS *>
<*+ NOHEADER *> 
<* IF NOT DEFINED(GENTYPEDEF) THEN *> <* NEW GENTYPEDEF+ *> <* END *>
<*+ CSTDLIB *>

DEFINITION MODULE ["C"] os9srvcb;

IMPORT os9types, os9module, os9moddir, os9process, os9io, os9lock, os9fork,
os9rbf, os9time, os9dexec, os9regs, os9regppc, os9alloc, os9settrap,
os9semaphore, SYSTEM;
(* H2D:  Required IMPORT clause: 
IMPORT os9srvcb, os9types, os9module, os9moddir, os9process, os9io, os9lock,
  os9fork, os9rbf, os9time, os9dexec, os9regs, os9regppc, os9alloc,
  os9settrap, os9semaphore;
*)


TYPE 
  syscb = RECORD
    code      : os9types.u_int16;     (*  function code number  *)
    edition   : os9types.u_int16;     (*  function edition number  *)
    error     : os9types.error_code;  (*  error code 0=success n=errnum  *)
    param_size: os9types.u_int32;     (*  size of parameter list  *)
  END;

(* ************************************************** *)
(*  parameter blocks for user state service routines  *)
(* ********************** *)
(*  i/o service requests  *)
(*  alias pathlist service request parameter block  *)

  i_alias_pb = RECORD
    cb        : syscb;
    alias_name: os9types.Ptru_char;  (*  assigned name  *)
    real_name : os9types.Ptru_char;  (*  device name  *)
  END;

  I_alias_pb = POINTER TO i_alias_pb;

(*  attach service request parameter block  *)

  i_attach_pb = RECORD
    cb     : syscb;
    name   : os9types.Ptru_char;
    mode   : os9types.u_int16;
    dev_tbl: os9io.Dev_list;    (*  output  *)
  END;

  I_attach_pb = POINTER TO i_attach_pb;

(*  chdir service request parameter block  *)

  i_chdir_pb = RECORD
    cb  : syscb;
    name: os9types.Ptru_char;
    mode: os9types.u_int16;
  END;

  I_chdir_pb = POINTER TO i_chdir_pb;

(*  close service request parameter block  *)

  i_close_pb = RECORD
    cb  : syscb;
    path: os9types.path_id;
  END;

  I_close_pb = POINTER TO i_close_pb;

(*  create service request parameter block  *)

  i_create_pb = RECORD
    cb  : syscb;
    name: os9types.Ptru_char;
    mode: os9types.u_int16;
    path: os9types.path_id;  (*  output  *)
    perm: os9types.u_int32;
    size: os9types.u_int32;
  END;

  I_create_pb = POINTER TO i_create_pb;

(*  configure an element of process/system I/O  *)

  i_config_pb = RECORD
    cb   : syscb;
    code : os9types.u_int32;
    param: SYSTEM.ADDRESS;
  END;

  I_config_pb = POINTER TO i_config_pb;

(*  delete service request parameter block  *)

  i_delete_pb = i_chdir_pb;

  I_delete_pb = I_chdir_pb;

(*  detach service request parameter block  *)

  i_detach_pb = RECORD
    cb     : syscb;
    dev_tbl: os9io.Dev_list;
  END;

  I_detach_pb = POINTER TO i_detach_pb;

(*  dup service request parameter block  *)

  i_dup_pb = RECORD
    cb      : syscb;
    dup_path: os9types.path_id;
    new_path: os9types.path_id;  (*  output  *)
  END;

  I_dup_pb = POINTER TO i_dup_pb;

(*  get system device list pointer service request parameter block  *)

  i_getdl_pb = i_detach_pb;

  I_getdl_pb = I_detach_pb;

(*  getstat service request parameter block  *)

  i_getstat_pb = RECORD
    cb       : syscb;
    path     : os9types.path_id;
    gs_code  : os9types.u_int16;
    param_blk: SYSTEM.ADDRESS;     (*  input/output  *)
  END;

  I_getstat_pb = POINTER TO i_getstat_pb;

(*  makdir service request parameter block  *)

  i_makdir_pb = RECORD
    cb  : syscb;
    name: os9types.Ptru_char;
    mode: os9types.u_int16;
    perm: os9types.u_int32;
    size: os9types.u_int32;
  END;

  I_makdir_pb = POINTER TO i_makdir_pb;

(*  open service request parameter block  *)

  i_open_pb = RECORD
    cb  : syscb;
    name: os9types.Ptru_char;
    mode: os9types.u_int16;
    path: os9types.path_id;  (*  output  *)
  END;

  I_open_pb = POINTER TO i_open_pb;

  i_rdalst_pb = RECORD
    cb    : syscb;
    buffer: os9types.Ptru_char;      (*  buffer to put alias element  *)
    count : os9types.u_int32;  (*  size of buffer  *)
  END;

  I_rdalst_pb = POINTER TO i_rdalst_pb;

(*  read service request parameter block  *)

  i_read_pb = RECORD
    cb    : syscb;
    path  : os9types.path_id;
    buffer: os9types.Ptru_char;
    count : os9types.u_int32;  (*  input/output  *)
  END;

  I_read_pb = POINTER TO i_read_pb;

(*  readln service request parameter block  *)

  i_readln_pb = i_read_pb;

  I_readln_pb = I_read_pb;

(*  seek service request parameter block  *)

  i_seek_pb = RECORD
    cb    : syscb;
    path  : os9types.path_id;
    offset: os9types.u_int32;
  END;

  I_seek_pb = POINTER TO i_seek_pb;

(*  setstat service request parameter block  *)

  i_setstat_pb = i_getstat_pb;

  I_setstat_pb = I_getstat_pb;

(*  write service request parameter block  *)

  i_write_pb = i_read_pb;

  I_write_pb = I_read_pb;

(*  writeln service request parameter block  *)

  i_writeln_pb = i_read_pb;

  I_writeln_pb = I_read_pb;

(* ************************** *)
(*  general service requests  *)
(*  abort a process as if the specified exception had occurred  *)

  f_abort_pb = RECORD
    cb        : syscb;
    strap_code: os9types.u_int32;  (*  STRAP_ identifier  *)
    address   : os9types.u_int32;  (*  fault address  *)
    except_id : os9types.u_int32;  (*  exception ID (optional)  *)
  END;

  F_abort_pb = POINTER TO f_abort_pb;

(*  set alarm clock service request parameter block  *)

  f_alarm_pb = RECORD
    cb       : syscb;
    alrm_id  : os9types.alarm_id;     (*  input/output  *)
    alrm_code: os9types.u_int16;
    time     : os9types.u_int32;
    signal   : os9types.signal_code;
  END;

  F_alarm_pb = POINTER TO f_alarm_pb;

(*  set alternate module directory parameter block  *)

  f_altmdir_pb = RECORD
    cb  : syscb;
    name: os9types.Ptru_char;
  END;

  F_altmdir_pb = POINTER TO f_altmdir_pb;

(*  cache control service request parameter block  *)

  f_cache_pb = RECORD
    cb     : syscb;
    control: os9types.u_int32;
    addr   : SYSTEM.ADDRESS;
    size   : os9types.u_int32;
  END;

  F_cache_pb = POINTER TO f_cache_pb;

(*  chain service request parameter block  *)

  f_chain_pb = RECORD
    cb        : syscb;
    priority  : os9types.u_int16;
    path_cnt  : os9types.u_int16;
    mod_name  : os9types.Ptru_char;
    params    : os9types.Ptru_char;
    mem_size  : os9types.u_int32;
    param_size: os9types.u_int32;
    type_lang : os9types.u_int16;
  END;

  F_chain_pb = POINTER TO f_chain_pb;

(*  chainm by module pointer service request parameter block  *)

  f_chainm_pb = RECORD
    cb        : syscb;
    priority  : os9types.u_int16;
    path_cnt  : os9types.u_int16;
    mod_head  : os9module.Mh_com;
    params    : os9types.Ptru_char;
    mem_size  : os9types.u_int32;
    param_size: os9types.u_int32;
  END;

  F_chainm_pb = POINTER TO f_chainm_pb;

(*  change module directories service request  *)

  f_chmdir_pb = f_altmdir_pb;

  F_chmdir_pb = F_altmdir_pb;

(*  clear signal queue service request  *)

  f_clrsigs_pb = i_close_pb;

  F_clrsigs_pb = I_close_pb;

(*  change module directory user identifier  *)

  f_cmdperm_pb = i_chdir_pb;

  F_cmdperm_pb = I_chdir_pb;

(*  compare name service request parameter block  *)

  f_cmpnam_pb = RECORD
    cb     : syscb;
    length : os9types.u_int32;
    string : os9types.Ptru_char;
    pattern: os9types.Ptru_char;
    result : os9types.int32;
  END;

  F_cmpnam_pb = POINTER TO f_cmpnam_pb;

(*  configure an element of process/system  *)

  f_config_pb = i_config_pb;

  F_config_pb = I_config_pb;

(*  copy memory service request parameter block  *)

  f_cpymem_pb = RECORD
    cb     : syscb;
    proc_id: os9types.process_id;
    from   : os9types.Ptru_char;
    to     : os9types.Ptru_char;
    count  : os9types.u_int32;
  END;

  F_cpymem_pb = POINTER TO f_cpymem_pb;

(*  generate crc service request parameter block  *)

  f_crc_pb = RECORD
    cb   : syscb;
    start: os9types.Ptru_char;
    count: os9types.u_int32;
    accum: os9types.u_int32;  (*  input/output  *)
  END;

  F_crc_pb = POINTER TO f_crc_pb;

(*  create data module service request parameter block  *)

  f_datmod_pb = RECORD
    cb       : syscb;
    mod_name : os9types.Ptru_char;
    size     : os9types.u_int32;
    attr_rev : os9types.u_int16;  (*  input/output  *)
    type_lang: os9types.u_int16;  (*  output  *)
    perm     : os9types.u_int16;
    mod_exec : SYSTEM.ADDRESS;     (*  output  *)
    mod_head : os9module.Mh_com;  (*  output  *)
  END;

  F_datmod_pb = POINTER TO f_datmod_pb;

(*  debug attach a process service request parameter block  *)

  f_dattach_pb = RECORD
    cb        : syscb;
    proc_id   : os9types.process_id;  (*  input - target debug process  *)
    reg_stack : os9regppc.Regs;      (*  output - process' register image  *)
    freg_stack: os9regppc.Fregs;     (*  output - process' FPU register image  *)
  END;

  F_dattach_pb = POINTER TO f_dattach_pb;

(*  delete module directory service request  *)

  f_delmdir_pb = f_altmdir_pb;

  F_delmdir_pb = F_altmdir_pb;

(*  debug execute call service request parameter block  *)

  f_dexec_pb = RECORD
    cb         : syscb;
    proc_id    : os9types.process_id;    (*  input - process identifier  *)
    mode       : os9dexec.dexec_mode;    (*  input - dexec execution mode  *)
    params     : os9types.Ptru_char;           (*  input - pointer to additional parameter(s)  *)
    num_instr  : os9types.u_int32;       (*  input/output - number of instructions  *)
    tot_instr  : os9types.u_int32;       (*  output - total instructions executed so far  *)
    except     : os9types.u_int32;       (*  exception number (on exception only)  *)
    addr       : os9types.u_int32;       (*  fault address (on exception only)  *)
    num_bpts   : os9types.u_int16;       (*  input - number of break points  *)
    brk_pts    : os9types.PtrPtru_int16;       (*  input - break point list  *)
    status     : os9dexec.dexec_status;  (*  output - return status code  *)
    exit_status: os9types.error_code;    (*  output - exit status of child process  *)
  END;

  F_dexec_pb = POINTER TO f_dexec_pb;

(*  debug exit call service request parameter block  *)

  f_dexit_pb = i_close_pb;

  F_dexit_pb = I_close_pb;

(*  debug fork call service request parameter block  *)

  f_dfork_pb = RECORD
    cb        : syscb;
    priority  : os9types.u_int16;
    path_cnt  : os9types.u_int16;
    proc_id   : os9types.process_id;  (*  output  *)
    reg_stack : os9regppc.Regs;      (*  input/output  *)
    freg_stack: os9regppc.Fregs;     (*  input/output  *)
    mod_name  : os9types.Ptru_char;
    params    : os9types.Ptru_char;
    mem_size  : os9types.u_int32;
    param_size: os9types.u_int32;
    type_lang : os9types.u_int16;
  END;

  F_dfork_pb = POINTER TO f_dfork_pb;

(*  debug fork by module pointer service request parameter block  *)

  f_dforkm_pb = RECORD
    cb        : syscb;
    priority  : os9types.u_int16;
    path_cnt  : os9types.u_int16;
    proc_id   : os9types.process_id;  (*  output  *)
    reg_stack : os9regppc.Regs;      (*  input/output  *)
    freg_stack: os9regppc.Fregs;     (*  input/output  *)
    mod_head  : os9module.Mh_com;
    params    : os9types.Ptru_char;
    mem_size  : os9types.u_int32;
    param_size: os9types.u_int32;
  END;

  F_dforkm_pb = POINTER TO f_dforkm_pb;

(* ***************************************************************** *)
(*  Event routines - cb._fcode are the same for all these routines  *)
(*  event creat service request parameter block  *)

  f_evcreat_pb = RECORD
    cb      : syscb;
    ev_code : os9types.u_int16;
    wait_inc: os9types.u_int16;
    sig_inc : os9types.u_int16;
    perm    : os9types.u_int16;
    color   : os9types.u_int16;
    ev_id   : os9types.event_id;  (*  output  *)
    ev_name : os9types.Ptru_char;
    value   : os9types.int32;
  END;

  F_evcreat_pb = POINTER TO f_evcreat_pb;

(*  event link service request parameter block  *)

  f_evlink_pb = RECORD
    cb     : syscb;
    ev_code: os9types.u_int16;
    ev_id  : os9types.event_id;  (*  output  *)
    ev_name: os9types.Ptru_char;
  END;

  F_evlink_pb = POINTER TO f_evlink_pb;

(*  event unlink service request parameter block  *)

  f_evunlnk_pb = RECORD
    cb     : syscb;
    ev_code: os9types.u_int16;
    ev_id  : os9types.event_id;
  END;

  F_evunlnk_pb = POINTER TO f_evunlnk_pb;

(*  event delete service request parameter block  *)

  f_evdelet_pb = RECORD
    cb     : syscb;
    ev_code: os9types.u_int16;
    ev_name: os9types.Ptru_char;
  END;

  F_evdelet_pb = POINTER TO f_evdelet_pb;

(*  event info service request parameter block  *)

  f_evinfo_pb = RECORD
    cb     : syscb;
    ev_code: os9types.u_int16;
    ev_id  : os9types.event_id;
    size   : os9types.u_int32;
    buffer : os9types.Ptru_char;
  END;

  F_evinfo_pb = POINTER TO f_evinfo_pb;

(*  event signal service request parameter block  *)

  f_evsignl_pb = RECORD
    cb       : syscb;
    ev_code  : os9types.u_int16;
    ev_id    : os9types.event_id;
    value    : os9types.int32;     (*  output  *)
    actv_flag: os9types.u_int32;
  END;

  F_evsignl_pb = POINTER TO f_evsignl_pb;

(*  event read service request parameter block  *)

  f_evread_pb = RECORD
    cb     : syscb;
    ev_code: os9types.u_int16;
    ev_id  : os9types.event_id;
    value  : os9types.int32;     (*  output  *)
  END;

  F_evread_pb = POINTER TO f_evread_pb;
(*  event pulse service request parameter block  *)
  f_evpulse_pb = f_evsignl_pb;
  F_evpulse_pb = F_evsignl_pb;
(*  event set service request parameter block  *)
  f_evset_pb = f_evsignl_pb;
  F_evset_pb = F_evsignl_pb;
(*  event set relative service request parameter block  *)
  f_evsetr_pb = f_evsignl_pb;
  F_evsetr_pb = F_evsignl_pb;
(*  event wait service request parameter block  *)
  f_evwait_pb = RECORD
    cb     : syscb;
    ev_code: os9types.u_int16;
    ev_id  : os9types.event_id;
    value  : os9types.int32;        (*  output  *)
    signal : os9types.signal_code;  (*  output  *)
    min_val: os9types.u_int32;
    max_val: os9types.u_int32;
  END;

  F_evwait_pb = POINTER TO f_evwait_pb;

(*  event wait relative service request parameter block  *)

  f_evwaitr_pb = RECORD
    cb     : syscb;
    ev_code: os9types.u_int16;
    ev_id  : os9types.event_id;
    value  : os9types.int32;        (*  output  *)
    signal : os9types.signal_code;  (*  output  *)
    min_val: os9types.u_int32;      (*  input/output  *)
    max_val: os9types.u_int32;      (*  input/output  *)
  END;

  F_evwaitr_pb = POINTER TO f_evwaitr_pb;
(*  event set OR service request parameter block  *)
  f_evsetor_pb = RECORD
    cb       : syscb;
    ev_code  : os9types.u_int16;
    ev_id    : os9types.event_id;
    value    : os9types.int32;     (*  output  *)
    mask     : os9types.u_int32;
    actv_flag: os9types.u_int32;
  END;

  F_evsetor_pb = POINTER TO f_evsetor_pb;
(*  event set AND service request parameter block  *)
  f_evsetand_pb = f_evsetor_pb;
  F_evsetand_pb = F_evsetor_pb;
(*  event set XOR service request parameter block  *)
  f_evsetxor_pb = f_evsetor_pb;
  F_evsetxor_pb = F_evsetor_pb;
(*  event wait any bits set service request parameter block  *)

  f_evanyset_pb = RECORD
    cb     : syscb;
    ev_code: os9types.u_int16;
    ev_id  : os9types.event_id;
    value  : os9types.int32;        (*  output  *)
    signal : os9types.signal_code;  (*  output  *)
    mask   : os9types.u_int32;
  END;

  F_evanyset_pb = POINTER TO f_evanyset_pb;
(*  event wait all bits set service request parameter block  *)
  f_evallset_pb = f_evanyset_pb;
  F_evallset_pb = F_evanyset_pb;
(*  event wait any bits clear service request parameter block  *)
  f_evanyclr_pb = f_evanyset_pb;
  F_evanyclr_pb = F_evanyset_pb;
(*  event wait all bits clear service request parameter block  *)
  f_evallclr_pb = f_evanyset_pb;
  F_evallclr_pb = F_evanyset_pb;
(*  event wait test and set service request parameter block  *)
  f_evtstset_pb = f_evanyset_pb;
  F_evtstset_pb = F_evanyset_pb;
(*  event wait change service request parameter block  *)
  f_evchange_pb = f_evwait_pb;
  F_evchange_pb = F_evwait_pb;
(*  exit service request parameter block  *)
  f_exit_pb = i_close_pb;
  F_exit_pb = I_close_pb;

(*  find module entry service request  *)

  f_findmod_pb = RECORD
    cb          : syscb;
    type_lang   : os9types.u_int16;   (*  input/ouput  *)
    moddir_entry: os9moddir.Mod_dir;  (*  output  *)
    mod_name    : os9types.Ptru_char;
  END;

  F_findmod_pb = POINTER TO f_findmod_pb;

(*  fork service request parameter block  *)

  f_fork_pb = RECORD
    cb        : syscb;
    priority  : os9types.u_int16;
    path_cnt  : os9types.u_int16;
    proc_id   : os9types.process_id;  (*  output  *)
    mod_name  : os9types.Ptru_char;
    params    : os9types.Ptru_char;
    mem_size  : os9types.u_int32;
    param_size: os9types.u_int32;
    type_lang : os9types.u_int16;
    orphan    : os9types.u_int16;
  END;

  F_fork_pb = POINTER TO f_fork_pb;

(*  fork by module pointer service request parameter block  *)

  f_forkm_pb = RECORD
    cb        : syscb;
    priority  : os9types.u_int16;
    path_cnt  : os9types.u_int16;
    proc_id   : os9types.process_id;  (*  output  *)
    mod_head  : os9module.Mh_com;
    params    : os9types.Ptru_char;
    mem_size  : os9types.u_int32;
    param_size: os9types.u_int32;
    orphan    : os9types.u_int16;
  END;

  F_forkm_pb = POINTER TO f_forkm_pb;

(*  get free memory block map request service request parameter block  *)

  f_gblkmp_pb = RECORD
    cb       : syscb;
    start    : os9alloc.Mem_list;
    buffer   : os9types.Ptru_char;       (*  intput/output  *)
    size     : os9types.u_int32;
    min_alloc: os9types.u_int32;   (*  output  *)
    num_segs : os9types.u_int32;   (*  output  *)
    tot_mem  : os9types.u_int32;   (*  output  *)
    free_mem : os9types.u_int32;   (*  output  *)
  END;

  F_gblkmp_pb = POINTER TO f_gblkmp_pb;

(*  getime service request parameter block  *)

  f_getime_pb = RECORD
    cb   : syscb;
    time : os9types.u_int32;  (*  output  *)
    ticks: os9types.u_int32;  (*  output  *)
  END;

  F_getime_pb = POINTER TO f_getime_pb;

(*  get module directory pathlists service request parameter block  *)

  f_get_mdp_pb = RECORD
    cb       : syscb;
    current  : os9types.Ptru_char;
    alternate: os9types.Ptru_char;
  END;

  F_get_mdp_pb = POINTER TO f_get_mdp_pb;

(*  get module directory service request parameter block  *)

  f_get_moddir_pb = RECORD
    cb    : syscb;
    buffer: os9types.Ptru_char;
    count : os9types.u_int32;  (*  input/output  *)
  END;

  F_get_moddir_pb = POINTER TO f_get_moddir_pb;

(*  get process table service request parameter block  *)

  f_get_prtbl_pb = f_get_moddir_pb;
  F_get_prtbl_pb = F_get_moddir_pb;

(*  get system global variable service request parameter block  *)

  f_getsys_pb = RECORD
    cb    : syscb;
    offset: os9types.u_int32;  (*  offset into system globals  *)
    size  : os9types.u_int32;  (*  size of variable: 1, 2, or 4 bytes  *)
    sysvar: RECORD
               CASE : INTEGER OF
                   0: byt: os9types.u_char;   (*  byte size variable  *)
                  |1: wrd: os9types.u_int16;  (*  word size variable  *)
                  |2: lng: os9types.u_int32;  (*  lonk size variable  *)
               END;
            END;
  END;

  F_getsys_pb = POINTER TO f_getsys_pb;

(*  get process descriptor copy service request parameter block  *)

  f_gprdsc_pb = RECORD
    cb     : syscb;
    proc_id: os9types.process_id;
    buffer : os9types.Ptru_char;
    count  : os9types.u_int32;
  END;

  F_gprdsc_pb = POINTER TO f_gprdsc_pb;

(*  process identification service request parameter block  *)

  f_id_pb = RECORD
    cb      : syscb;
    proc_id : os9types.process_id;  (*  output  *)
    priority: os9types.u_int16;     (*  output  *)
    age     : os9types.u_int16;     (*  output  *)
    schedule: os9types.int32;       (*  output  *)
    user_id : os9types.owner_id;    (*  output  *)
  END;

  F_id_pb = POINTER TO f_id_pb;

(*  initialize process data area service request  *)

  f_init_data_pb = RECORD
    cb      : syscb;
    mod_head: os9module.Mh_com;
    data    : os9types.Ptru_char;
  END;

  F_init_data_pb = POINTER TO f_init_data_pb;

(*  signal intercept service request parameter block  *)

  f_intercept_pb = RECORD
    cb      : syscb;
    function: os9types.ProcBYTEu32;
    data_ptr: SYSTEM.ADDRESS;
  END;

  F_intercept_pb = POINTER TO f_intercept_pb;

(*  module link service request parameter block  *)

  f_link_pb = RECORD
    cb       : syscb;
    mod_name : os9types.Ptru_char;
    mod_head : os9module.Mh_com;  (*  output  *)
    mod_exec : SYSTEM.ADDRESS;     (*  output  *)
    type_lang: os9types.u_int16;  (*  input/output  *)
    attr_rev : os9types.u_int16;  (*  output  *)
  END;

  F_link_pb = POINTER TO f_link_pb;

(*  module link by module pointer service request parameter block  *)

  f_linkm_pb = RECORD
    cb       : syscb;
    mod_head : os9module.Mh_com;  (*  input  *)
    mod_exec : SYSTEM.ADDRESS;     (*  output  *)
    type_lang: os9types.u_int16;  (*  output  *)
    attr_rev : os9types.u_int16;  (*  output  *)
  END;

  F_linkm_pb = POINTER TO f_linkm_pb;

(*  module load service request parameter block  *)

  f_load_pb = RECORD
    cb       : syscb;
    mod_name : os9types.Ptru_char;
    mod_head : os9module.Mh_com;  (*  output  *)
    mod_exec : SYSTEM.ADDRESS;     (*  output  *)
    mode     : os9types.u_int32;
    type_lang: os9types.u_int16;  (*  output  *)
    attr_rev : os9types.u_int16;  (*  output  *)
    color    : os9types.u_int16;
  END;

  F_load_pb = POINTER TO f_load_pb;

(*  create module directory service request parameter block  *)

  f_makmdir_pb = i_chdir_pb;
  F_makmdir_pb = I_chdir_pb;

(*  memory area resize service request parameter block  *)

  f_mem_pb = i_rdalst_pb;
  F_mem_pb = I_rdalst_pb;

(*  get module header address given a pointer service request  *)

  f_modaddr_pb = RECORD
    cb      : syscb;
    mem_ptr : os9types.Ptru_char;      (*  input  *)
    mod_head: os9module.Mh_com;  (*  output  *)
  END;

  F_modaddr_pb = POINTER TO f_modaddr_pb;

(*  parse name service request parameter block  *)

  f_prsnam_pb = RECORD
    cb       : syscb;
    name     : os9types.Ptru_char;
    length   : os9types.u_int32;  (*  output  *)
    delimiter: os9types.u_char;   (*  output  *)
    updated  : os9types.Ptru_char;      (*  output  *)
  END;

  F_prsnam_pb = POINTER TO f_prsnam_pb;

(*  return from interrupt exception service request parameter block  *)

  f_rte_pb = RECORD
    cb  : syscb;
    mode: os9types.u_int32;  (*             mode of return - 0 = normal signal return  *)
                              (* 										1 = clean stack only (for longjmp)           *)
  END;

  F_rte_pb = POINTER TO f_rte_pb;

(*  semaphore service request parameter block  *)

  f_sema_pb = RECORD
    cb       : syscb;
    sema     : os9semaphore.Semaphore;  (*  semaphore structure pointer  *)
    operation: os9types.u_int32;        (*  semaphore operation code  *)
  END;

  F_sema_pb = POINTER TO f_sema_pb;

(*  send signal service request parameter block  *)

  f_send_pb = RECORD
    cb     : syscb;
    proc_id: os9types.process_id;
    signal : os9types.signal_code;
  END;

  F_send_pb = POINTER TO f_send_pb;

(*  generate crc in module service request parameter block  *)

  f_setcrc_pb = RECORD
    cb      : syscb;
    mod_head: os9module.Mh_com;
  END;

  F_setcrc_pb = POINTER TO f_setcrc_pb;

(*  setime service request parameter block  *)

  f_setime_pb = RECORD
    cb  : syscb;
    time: os9types.u_int32;
  END;

  F_setime_pb = POINTER TO f_setime_pb;

(*  set priority service request parameter block  *)

  f_setpr_pb = RECORD
    cb      : syscb;
    proc_id : os9types.process_id;
    priority: os9types.u_int16;
  END;

  F_setpr_pb = POINTER TO f_setpr_pb;

(*  set system global variable service request parameter block  *)

  f_setsys_pb = f_getsys_pb;

  F_setsys_pb = F_getsys_pb;

(*  set user id service request parameter block  *)

  f_setuid_pb = RECORD
    cb     : syscb;
    user_id: os9types.owner_id;  (*  output  *)
  END;

  F_setuid_pb = POINTER TO f_setuid_pb;

(*  set signal mask value and return on specified stack image  *)

  f_siglngj_pb = RECORD
    cb    : syscb;
    usp   : SYSTEM.ADDRESS;
    siglvl: os9types.u_int16;
  END;

  F_siglngj_pb = POINTER TO f_siglngj_pb;

(*  signal masking service request parameter block  *)

  f_sigmask_pb = f_setime_pb;
  F_sigmask_pb = F_setime_pb;

(*  resize process' signal queue block parameter block  *)

  f_sigrs_pb = f_setime_pb;
  F_sigrs_pb = F_setime_pb;

(*  reset process' intercept routine recursion depth to zero  *)

  f_sigrst_pb = RECORD
    cb: syscb;
  END;

  F_sigrst_pb = POINTER TO f_sigrst_pb;

(*  sleep service request parameter block  *)

  f_sleep_pb = RECORD
    cb    : syscb;
    ticks : os9types.u_int32;      (*  input/output  *)
    signal: os9types.signal_code;  (*  output  *)
  END;

  F_sleep_pb = POINTER TO f_sleep_pb;

(*  link subroutine library module service request parameter block  *)

  f_slink_pb = RECORD
    cb      : syscb;
    sub_num : os9types.u_int16;  (*  input  *)
    mod_name: os9types.Ptru_char;      (*  input  *)
    lib_exec: SYSTEM.ADDRESS;     (*  output  *)
    mem_ptr : os9types.Ptru_char;      (*  output  *)
    mod_head: os9module.Mh_com;  (*  output  *)
  END;

  F_slink_pb = POINTER TO f_slink_pb;

(*  link subroutine library module by pointer service request parameter block  *)

  f_slinkm_pb = RECORD
    cb      : syscb;
    sub_num : os9types.u_int16;  (*  input  *)
    mod_head: os9module.Mh_com;  (*  input  *)
    lib_exec: SYSTEM.ADDRESS;     (*  output  *)
    mem_ptr : os9types.Ptru_char;      (*  output  *)
  END;

  F_slinkm_pb = POINTER TO f_slinkm_pb;

(*  memory request service request parameter block  *)

  f_srqmem_pb = RECORD
    cb     : syscb;
    mem_ptr: os9types.Ptru_char;      (*  output  *)
    size   : os9types.u_int32;  (*  input/output  *)
    color  : os9types.u_int16;
  END;

  F_srqmem_pb = POINTER TO f_srqmem_pb;

(*  memory return service request parameter block  *)

  f_srtmem_pb = RECORD
    cb     : syscb;
    mem_ptr: os9types.Ptru_char;
    size   : os9types.u_int32;
  END;

  F_srtmem_pb = POINTER TO f_srtmem_pb;

(*  set error trap handler service request parameter block  *)

  f_strap_pb = RECORD
    cb         : syscb;
    excpt_stack: os9types.Ptru_char;
    init_tbl   : os9settrap.Strap;
  END;

  F_strap_pb = POINTER TO f_strap_pb;

(*  sysdbg call service request parameter block  *)

  f_sysdbg_pb = RECORD
    cb    : syscb;
    param1: os9types.Ptru_int32;
    param2: os9types.Ptru_int32;
  END;

  F_sysdbg_pb = POINTER TO f_sysdbg_pb;

(*  return system identification service request parameter block  *)

  f_sysid_pb = RECORD
    cb       : syscb;
    oem      : os9types.u_int32;
    serial   : os9types.u_int32;
    mpu_type : os9types.u_int32;
    os_type  : os9types.u_int32;
    fpu_type : os9types.u_int32;
    time_zone: os9types.int32;
    resv1    : os9types.u_int32;
    resv2    : os9types.u_int32;
    sys_ident: os9types.Ptru_char;
    copyright: os9types.Ptru_char;
    resv3    : os9types.Ptru_char;
  END;

  F_sysid_pb = POINTER TO f_sysid_pb;

(*  exit from trap handler termination routine service request parameter block  *)

  f_texit_pb = RECORD
    cb      : syscb;
    trap_num: os9types.u_int16;
  END;

  F_texit_pb = POINTER TO f_texit_pb;

(*  install user trap handler service request parameter block  *)

  f_tlink_pb = RECORD
    cb      : syscb;
    trap_num: os9types.u_int16;
    mod_name: os9types.Ptru_char;
    lib_exec: SYSTEM.ADDRESS;     (*  output  *)
    mod_head: SYSTEM.ADDRESS;     (*  output  *)
    params  : SYSTEM.ADDRESS;     (*  output  *)
    mem_size: os9types.u_int32;
  END;

  F_tlink_pb = POINTER TO f_tlink_pb;

(*  install user trap handler by pointer service request parameter block  *)

  f_tlinkm_pb = RECORD
    cb      : syscb;
    trap_num: os9types.u_int16;
    mod_head: os9module.Mh_com;
    lib_exec: SYSTEM.ADDRESS;     (*  output  *)
    params  : SYSTEM.ADDRESS;     (*  output  *)
    mem_size: os9types.u_int32;
  END;

  F_tlinkm_pb = POINTER TO f_tlinkm_pb;

(*  user accounting service request parameter block  *)

  f_uacct_pb = RECORD
    cb       : syscb;
    acct_code: os9types.u_int16;
    proc_desc: os9process.Pr_desc;
    (*   	void          *)   (* 		*vsect_ptr;    *)
  END;

  F_uacct_pb = POINTER TO f_uacct_pb;

(*  module unlink service request parameter block  *)

  f_unlink_pb = f_setcrc_pb;
  F_unlink_pb = F_setcrc_pb;

(*  module unload service request parameter block  *)

  f_unload_pb = i_chdir_pb;
  F_unload_pb = I_chdir_pb;

(*  wait service request parameter block  *)

  f_wait_pb = RECORD
    cb      : syscb;
    child_id: os9types.process_id;   (*  output  *)
    status  : os9types.status_code;  (*  output  *)
  END;

  F_wait_pb = POINTER TO f_wait_pb;

(*  get VPC Memory address parameter block  *)

  f_getvpcmem_pb = RECORD
    cb     : syscb;
    vpc_pid: os9types.process_id;  (*  input  *)
    vpc_mem: os9types.u_int32;     (*  output *)
  END;

  F_getvpcmem_pb = POINTER TO f_getvpcmem_pb;

(*  Get VPC Shared Memory Event parameter block  *)

  f_vpc_gmemev_pb = RECORD
    cb     : syscb;
    vpc_pid: os9types.process_id;
    ev_id  : os9types.event_id;
    size   : os9types.Ptru_int32;
  END;

  F_vpc_gmemev_pb = POINTER TO f_vpc_gmemev_pb;

(*  Drop VPC Shared Memory Event parameter block  *)

  f_vpc_dmemev_pb = i_close_pb;
  F_vpc_dmemev_pb = I_close_pb;

(*  struct for Get VPC Processes Table  *)

  f_get_vpcptab_pb = RECORD
    cb   : syscb;
    count: os9types.Ptru_int32;
    table: os9types.Ptru_int32;
  END;

  F_get_vpcptab_pb = POINTER TO f_get_vpcptab_pb;

(* ******************************************************** *)
(* ** parameter blocks for system state service routines ** *)
(* ******************************************************** *)

  f_aproc_pb = i_close_pb;
  F_aproc_pb = I_close_pb;
  f_allprc_pb = RECORD
    cb       : syscb;
    proc_id  : os9types.process_id;  (*  output  *)
    proc_desc: os9process.Pr_desc;   (*  output  *)
  END;

  F_allprc_pb = POINTER TO f_allprc_pb;

  f_alltsk_pb = RECORD
    cb       : syscb;
    proc_desc: os9process.Pr_desc;
  END;

  F_alltsk_pb = POINTER TO f_alltsk_pb;

(*  verify memory is accessable (spu) service request parameter block  *)

  f_chkmem_pb = RECORD
    cb       : syscb;
    size     : os9types.u_int32;
    mode     : os9types.u_int16;
    mem_ptr  : os9types.Ptru_char;
    proc_desc: os9process.Pr_desc;
  END;

  F_chkmem_pb = POINTER TO f_chkmem_pb;
  f_deltsk_pb = f_alltsk_pb;
  F_deltsk_pb = F_alltsk_pb;

(*  get process desc ptr service request parameter block  *)

  f_findpd_pb = RECORD
    cb       : syscb;
    proc_id  : os9types.process_id;
    proc_desc: os9process.Pr_desc;   (*  output  *)
  END;

  F_findpd_pb = POINTER TO f_findpd_pb;

  f_irq_pb = RECORD
    cb       : syscb;
    vector   : os9types.u_int16;
    priority : os9types.u_int16;
    irq_entry: SYSTEM.ADDRESS;
    statics  : os9types.Ptru_char;
  END;

  F_irq_pb = POINTER TO f_irq_pb;

  f_move_pb = RECORD
    cb   : syscb;
    from : os9types.Ptru_char;
    to   : os9types.Ptru_char;
    count: os9types.u_int32;
  END;

  F_move_pb = POINTER TO f_move_pb;

  f_msfork_pb = RECORD
    cb        : syscb;
    msdos_name: os9types.Ptru_char;      (*  msdos file path list  *)
    bios_data : os9types.Ptru_int32;     (*  bios data area  *)
    data_size : os9types.u_int32;  (*  size of msdos area  *)
    bios_init : os9types.ProcBYTEu32;        (*  pointer to bios init routine  *)
    mode      : os9types.u_int16;  (*  open mode for msdos & prog  *)
    unforking : os9types.u_char;   (*  0 if forking, 1 if unforking  *)
  END;

  F_msfork_pb = POINTER TO f_msfork_pb;
  f_nproc_pb = f_sigrst_pb;
  F_nproc_pb = F_sigrst_pb;
  f_permit_pb = RECORD
    cb     : syscb;
    pid    : os9types.process_id;
    size   : os9types.u_int32;
    mem_ptr: os9types.Ptru_char;
    perm   : os9types.u_int16;
  END;

  F_permit_pb = POINTER TO f_permit_pb;
  f_protect_pb = f_permit_pb;
  F_protect_pb = F_permit_pb;
  f_retpd_pb = i_close_pb;
  F_retpd_pb = I_close_pb;
(*  set alarm clock service request parameter block  *)

  f_salarm_pb = RECORD
    cb       : syscb;
    alrm_id  : os9types.alarm_id;  (*  input/output  *)
    alrm_code: os9types.u_int16;
    time     : os9types.u_int32;
    flags    : os9types.u_int32;
    function : os9types.ProcBYTEu32;
    func_pb  : SYSTEM.ADDRESS;
  END;

  F_salarm_pb = POINTER TO f_salarm_pb;

(*  system state cache control service request parameter block  *)

  f_scache_pb = RECORD
    cb       : syscb;
    control  : os9types.u_int32;
    cctl     : os9types.ProcBYTEu32;
    cctl_data: SYSTEM.ADDRESS;
    addr     : SYSTEM.ADDRESS;
    size     : os9types.u_int32;
  END;

  F_scache_pb = POINTER TO f_scache_pb;

  f_sspd_pb = i_close_pb;
  F_sspd_pb = I_close_pb;

  f_ssvc_pb = RECORD
    cb        : syscb;
    count     : os9types.u_int32;
    state_flag: os9types.u_int16;
    init_tbl  : SYSTEM.ADDRESS;
    params    : SYSTEM.ADDRESS;
  END;

  F_ssvc_pb = POINTER TO f_ssvc_pb;

  f_vmodul_pb = RECORD
    cb        : syscb;
    mod_head  : os9module.Mh_com;
    mod_block : os9module.Mh_com;
    block_size: os9types.u_int32;
  END;

  F_vmodul_pb = POINTER TO f_vmodul_pb;

  f_vpermit_pb = RECORD
    cb      : syscb;
    pid     : os9types.process_id;
    size    : os9types.u_int32;
    pmem_ptr: os9types.Ptru_char;
    vmem_ptr: os9types.Ptru_char;
    perm    : os9types.u_int16;
  END;

  F_vpermit_pb = POINTER TO f_vpermit_pb;

(*  Allocate path descriptor service request  *)

  i_allpd_pb = RECORD
    cb       : syscb;
    size     : os9types.u_int32;  (*  requested size of path descriptor  *)
    path_desc: os9io.Pd_com;      (*  output  *)
  END;

  I_allpd_pb = POINTER TO i_allpd_pb;

(*  Acquire resource lock service request.  *)

  f_acqlk_pb = RECORD
    cb    : syscb;
    lid   : os9lock.lock_id;       (*  queue to acquire  *)
    signal: os9types.signal_code;  (*  if signal occurs  *)
  END;

  F_acqlk_pb = POINTER TO f_acqlk_pb;

(*  Conditionally acquire resource lock service request.  *)

  f_caqlk_pb = RECORD
    cb : syscb;
    lid: os9lock.lock_id;  (*  queue to acquire  *)
  END;

  F_caqlk_pb = POINTER TO f_caqlk_pb;

(*  Create resource lock service request.  *)

  f_crlk_pb = f_caqlk_pb;
  F_crlk_pb = F_caqlk_pb;
  f_ddlk_pb = i_close_pb;
  F_ddlk_pb = I_close_pb;
(*  Delete resource lock service request.  *)
  f_dellk_pb = f_caqlk_pb;
  F_dellk_pb = F_caqlk_pb;
(*  Release resource lock service request.  *)
  f_rellk_pb = f_caqlk_pb;
  F_rellk_pb = F_caqlk_pb;

(*  Translate a memory address  *)

  f_transadd_pb = RECORD
    cb      : syscb;
    size    : os9types.u_int32;  (*  block size to xlate (in), size xlated (out)  *)
    mode    : os9types.u_int32;  (*  direction of xlation (input)  *)
    blk_addr: SYSTEM.ADDRESS;     (*  addr to xlate (input), xlated addr (output)  *)
    reserved: SYSTEM.ADDRESS;     (*  reserved  *)
  END;

  F_transadd_pb = POINTER TO f_transadd_pb;

(*  Find a free space in a user map  *)

  f_findfree_pb = RECORD
    cb       : syscb;
    pid      : os9types.process_id;  (*  the process context to use  *)
    direction: os9types.u_int32;     (*  from upper or from lower  *)
    size     : os9types.u_int32;     (*  amount of free space needed  *)
    paddr    : os9types.Ptru_char;         (*  the physical address  *)
    vaddr    : os9types.Ptru_char;         (*  a suitable virtual location  *)
  END;

  F_findfree_pb = POINTER TO f_findfree_pb;

(*  Wait on resource lock service request.  *)

  f_waitlk_pb = f_acqlk_pb;
  F_waitlk_pb = F_acqlk_pb;
  i_cioproc_pb = RECORD
    cb     : syscb;
    proc_id: os9types.process_id;  (*  process id for I/O process descriptor  *)
    buffer : SYSTEM.ADDRESS;        (*  pointer to buffer for I/O process descriptor  *)
    count  : os9types.u_int32;     (*  number of bytes desired  *)
  END;

  I_cioproc_pb = POINTER TO i_cioproc_pb;

(*  Find path descriptor service request  *)

  i_getpd_pb = RECORD
    cb       : syscb;
    path     : os9types.path_id;
    path_desc: os9io.Pd_com;      (*  output  *)
  END;

  I_getpd_pb = POINTER TO i_getpd_pb;

(*  Return pointer to I/O process descriptor  *)

  i_gioproc_pb = RECORD
    cb       : syscb;
    proc_id  : os9types.process_id;  (*  process id for I/O process descriptor  *)
    proc_desc: os9io.Io_proc;        (*  output, I/O process descriptor  *)
  END;

  I_gioproc_pb = POINTER TO i_gioproc_pb;

(*  Return copy of I/O process descriptor  *)
(*  I/O delete service request parameter block  *)

  i_iodel_pb = f_setcrc_pb;
  I_iodel_pb = F_setcrc_pb;

(*  Terminate I/O for exiting process service request parameter block  *)

  i_ioexit_pb = RECORD
    cb      : syscb;
    proc_id : os9types.process_id;  (*  process id of terminating process  *)
    path_cnt: os9types.u_int32;     (*  paths to remain open, high order bit  *)
    (*  set means chain.  *)
  END;

  I_ioexit_pb = POINTER TO i_ioexit_pb;

(*  Setup I/O for new process service request parameter block  *)

  i_iofork_pb = RECORD
    cb         : syscb;
    par_proc_id: os9types.process_id;  (*  process id of parent  *)
    new_proc_id: os9types.process_id;  (*  process id of new process  *)
    path_cnt   : os9types.u_int32;     (*  number of paths to be inherited from parent  *)
  END;

  I_iofork_pb = POINTER TO i_iofork_pb;
(*  Return path descriptor service request  *)
  i_retpd_pb = i_dup_pb;
  I_retpd_pb = I_dup_pb;

(*  Translate user path to system path service request.  *)

  i_tranpn_pb = RECORD
    cb       : syscb;
    proc_id  : os9types.process_id;
    user_path: os9types.path_id;
    sys_path : os9types.path_id;
  END;

  I_tranpn_pb = POINTER TO i_tranpn_pb;

(*   --------------------------------------------------------------------------!  *)
(* ! setstat parameter sub-block structure defs								!                          *)
(* !--------------------------------------------------------------------------    *)
(*  SS_PathOpt parameter sub-block	 *)

  ss_popt_pb = RECORD
    popt_size : os9types.u_int32;  (*  size of default options to copy	 *)
    user_popts: SYSTEM.ADDRESS;     (*  default options buffer pointer	 *)
  END;

  Ss_popt_pb = POINTER TO ss_popt_pb;

(*  SS_sendsig parameter sub-block	 *)

  ss_sendsig_pb = RECORD
    signal: os9types.signal_code;  (*  user defined signal code			 *)
  END;

  Ss_sendsig_pb = POINTER TO ss_sendsig_pb;

(*  SS_DCOn parameter sub-block	 *)

  ss_dcon_pb = ss_sendsig_pb;

  Ss_dcon_pb = Ss_sendsig_pb;

(*  SS_DCOff parameter sub-block	 *)

  ss_dcoff_pb = ss_sendsig_pb;

  Ss_dcoff_pb = Ss_sendsig_pb;

(*  SS_Size parameter sub-block	 *)

  ss_size_pb = RECORD
    filesize: os9types.u_int32;  (*  new file size					 *)
  END;

  Ss_size_pb = POINTER TO ss_size_pb;

(*  SS_wtrack parameter sub-block	 *)

  ss_wtrack_pb = RECORD
    trkbuf    : SYSTEM.ADDRESS;     (*  the track buffer					 *)
    ilvtbl    : SYSTEM.ADDRESS;     (*  the interleave table				 *)
    track     : os9types.u_int32;  (*  track number						 *)
    head      : os9types.u_int32;  (*  the head number					 *)
    interleave: os9types.u_int32;  (*  interleave value					 *)
  END;

  Ss_wtrack_pb = POINTER TO ss_wtrack_pb;

(*  SS_Fd parameter sub-block	 *)

  ss_fd_pb = RECORD
    fd_info: os9rbf.Fd_stats;  (*  info for the fd					 *)
  END;

  Ss_fd_pb = POINTER TO ss_fd_pb;

(*  SS_Ticks parameter sub-block  *)

  ss_ticks_pb = RECORD
    delay: os9types.u_int32;  (*  lockout sleep count 				 *)
  END;

  Ss_ticks_pb = POINTER TO ss_ticks_pb;

(*  SS_Lock parameter sub-block	 *)

  ss_lock_pb = RECORD
    size: os9types.u_int32;  (*  lockout size						 *)
  END;

  Ss_lock_pb = POINTER TO ss_lock_pb;

(*  SS_LUOPT parameter sub-block	 *)

  ss_luopt_pb = RECORD
    luopt_size : os9types.u_int32;  (*  size of logical unit options to copy	 *)
    user_luopts: SYSTEM.ADDRESS;     (*  logical unit options buffer pointer  *)
  END;

  Ss_luopt_pb = POINTER TO ss_luopt_pb;

(*  SS_Attr parameter sub-block	 *)

  ss_attr_pb = RECORD
    attr: os9types.u_int32;  (*  attributes						 *)
  END;

  Ss_attr_pb = POINTER TO ss_attr_pb;

(*  SS_DevOpt parameter sub-block	 *)

  ss_dopt_pb = RECORD
    dopt_size : os9types.u_int32;  (*  size of path options to copy	 *)
    user_dopts: SYSTEM.ADDRESS;     (*  device options buffer pointer  *)
  END;

  Ss_dopt_pb = POINTER TO ss_dopt_pb;

(*  SS_Rename parameter sub block 		 *)

  ss_rename_pb = RECORD
    newname: os9types.PtrSChar;  (*  the new file name  *)
  END;

  Ss_rename_pb = POINTER TO ss_rename_pb;

(*  Ss_FillBuff parameter sub-block	 *)

  ss_fillbuff_pb = RECORD
    size     : os9types.u_int32;  (*  size of buffer passed			 *)
    user_buff: os9types.Ptru_char;      (*  user buffer pointer				 *)
  END;

  Ss_fillbuff_pb = POINTER TO ss_fillbuff_pb;

(*  Ss_link parameter sub-block 		 *)

  ss_link_pb = RECORD
    link_path: os9types.Ptru_char;  (*  pathlist for the link			 *)
  END;

  Ss_link_pb = POINTER TO ss_link_pb;

(*  Ss_cache parameter sub-block 	 *)

  ss_cache_pb = RECORD
    enblflag: os9types.u_int32;  (*  cache enable/disable flag 		 *)
    drvcsize: os9types.u_int32;  (*  size of cache for drive in bytes  *)
  END;

  Ss_cache_pb = POINTER TO ss_cache_pb;

(*  Ss_link_adj parameter block  *)

  ss_link_adj_pb = RECORD
    fd_addr : os9types.u_int32;
    link_adj: os9types.int32;
  END;

  Ss_link_adj_pb = POINTER TO ss_link_adj_pb;

(*  Ss_skip_pb parameter sub-block 	 *)

  ss_skip_pb = RECORD
    blks: os9types.int32;  (*  SIGNED number of blocks to skip  *)
  END;

  Ss_skip_pb = POINTER TO ss_skip_pb;

(*  Ss_erase_pb parameter sub-block 	 *)

  ss_erase_pb = ss_skip_pb;

  Ss_erase_pb = Ss_skip_pb;

(*  Ss_rfm_pb read file mark parameter block *)

  ss_rfm_pb = RECORD
    cnt: os9types.int32;  (*  number of marks to read  *)
  END;

  Ss_rfm_pb = POINTER TO ss_rfm_pb;

(*  Ss_wfm_pb write file mark parameter block  *)

  ss_wfm_pb = RECORD
    cnt: os9types.u_int32;  (*  number of marks to write  *)
  END;

  Ss_wfm_pb = POINTER TO ss_wfm_pb;

(*   --------------------------------------------------------------------------!  *)
(* ! getstat parameter sub-block structure defs								!                          *)
(* !--------------------------------------------------------------------------    *)
(*  GS_PathOpt parameter sub-block	 *)

  gs_popt_pb = ss_popt_pb;

  Gs_popt_pb = Ss_popt_pb;

(*  GS_Ready parameter sub-block	 *)

  gs_ready_pb = RECORD
    incount: os9types.u_int32;  (*  return input buffer count		 *)
  END;

  Gs_ready_pb = POINTER TO gs_ready_pb;

(*  GS_DevOpt parameter sub-block	 *)

  gs_dopt_pb = ss_dopt_pb;

  Gs_dopt_pb = Ss_dopt_pb;

(*  GS_LUOPT parameter sub-block	 *)

  gs_luopt_pb = ss_luopt_pb;

  Gs_luopt_pb = Ss_luopt_pb;

(*  GS_Size parameter sub-block	 *)

  gs_size_pb = ss_size_pb;

  Gs_size_pb = Ss_size_pb;

(*  GS_Pos parameter sub-block	 *)

  gs_pos_pb = RECORD
    filepos: os9types.u_int32;  (*  current file position (output)	 *)
  END;

  Gs_pos_pb = POINTER TO gs_pos_pb;

(*  GS_EOF parameter sub-block	 *)

  gs_eof_pb = RECORD
    eof: os9types.u_int32;  (*  eof == 1 if eof					 *)
  END;

  Gs_eof_pb = POINTER TO gs_eof_pb;

  gs_devname_pb = RECORD
    namebuf: os9types.Ptru_char;  (*  the buffer for the device name	 *)
  END;

  Gs_devname_pb = POINTER TO gs_devname_pb;

  gs_devtype_pb = RECORD
    type : os9types.u_int16;  (*  type  *)
    class: os9types.u_int16;  (*  class (sequential or random)  *)
  END;

  Gs_devtype_pb = POINTER TO gs_devtype_pb;

  gs_fd_pb = RECORD
    info_size: os9types.u_int32;  (*  amount of fd info to copy 		 *)
    fd_info  : os9rbf.Fd_stats;   (*  the buffer for the fd			 *)
  END;

  Gs_fd_pb = POINTER TO gs_fd_pb;

  gs_fdinf_pb = RECORD
    info_size : os9types.u_int32;  (*  size of the info 				 *)
    fd_blk_num: os9types.u_int32;  (*  block number of the fd 			 *)
    fd_info   : os9rbf.Fd_stats;   (*  the buffer for the fd 			 *)
  END;

  Gs_fdinf_pb = POINTER TO gs_fdinf_pb;

  gs_showuse_pb = RECORD
    mode    : os9types.int16;  (*  file manager/driver mode flag	 *)
    size    : os9types.int16;  (*  user buffer size					 *)
    user_buf: os9types.Ptru_int32;   (*  user buffer pointer				 *)
  END;

  Gs_showuse_pb = POINTER TO gs_showuse_pb;

  gs_fdaddr_pb = RECORD
    fd_blkaddr: os9types.u_int32;  (*  block address of fd				 *)
  END;

  Gs_fdaddr_pb = POINTER TO gs_fdaddr_pb;

(*  GS_DSIZE parameter block  *)

  gs_dsize_pb = RECORD
    totblocks: os9types.u_int32;  (*  total blocks on the disk 		 *)
    blocksize: os9types.u_int32;  (*  size of block 					 *)
  END;

  Gs_dsize_pb = POINTER TO gs_dsize_pb;

(*  GS_CSTATS parameter block  *)

  gs_cstats_pb = RECORD
    cache_inf: os9rbf.Cachestats;  (*  the cache information structure 	 *)
  END;

  Gs_cstats_pb = POINTER TO gs_cstats_pb;

(*  GS_PARITY parameter block  *)

  gs_parity_pb = RECORD
    fd    : os9rbf.Fd_stats;   (*  the fd buffer  *)
    parity: os9types.u_int32;  (*  the resulting parity  *)
  END;

  Gs_parity_pb = POINTER TO gs_parity_pb;

(*  SS_EDT parameter block  *)

  gs_edt_pb = RECORD
    edition: os9types.u_int32;
  END;

  Gs_edt_pb = POINTER TO gs_edt_pb;

(*  SS_COPYPD parameter block  *)

  gs_cpypd_pb = RECORD
    size     : os9types.u_int32;
    path_desc: SYSTEM.ADDRESS;
  END;

  Gs_cpypd_pb = POINTER TO gs_cpypd_pb;

(*  GS_CAPABILITIES parameter block  *)

  gs_capabilities_pb = RECORD
    size  : os9types.u_int32;   (*  buffer size/full string size  *)
    capstr: os9types.PtrSChar;        (*  capabilities string buffer ptr  *)
  END;

  Gs_capabilities_pb = POINTER TO gs_capabilities_pb;

(*  Generic Setstat parameter block for RTNFM setstat calls  *)

  ss_rtnfm_pb = RECORD
    ss_code: os9types.u_int16;
    rsvd   : os9types.u_int16;
    param1 : SYSTEM.ADDRESS;
    param2 : SYSTEM.ADDRESS;
  END;

  Ss_rtnfm_pb = POINTER TO ss_rtnfm_pb;

(*  Generic Getstat parameter block for RTNFM getstat calls  *)

  gs_rtnfm_pb = RECORD
    gs_code: os9types.u_int16;
    rsvd   : os9types.u_int16;
    param1 : SYSTEM.ADDRESS;
    param2 : SYSTEM.ADDRESS;
  END;

  Gs_rtnfm_pb = POINTER TO gs_rtnfm_pb;

(*  SS_delblk (delete sectors) parameter sub-block  *)

  ss_delblk_pb = RECORD
    irSectorNo   : os9types.u_int32;
    irSectorCount: os9types.u_int32;
  END;

  Ss_delblk_pb = POINTER TO ss_delblk_pb;

(*  SS_DISKFREE parameter block  *)

  gs_diskfree_pb = RECORD
    bavail : os9types.u_int32;
    bsize  : os9types.u_int32;
    blocks : os9types.u_int32;
    bcontig: os9types.u_int32;
  END;

  Gs_diskfree_pb = POINTER TO gs_diskfree_pb;

  PROCEDURE _oscall(arg0: SYSTEM.ADDRESS): os9types.error_code;
END os9srvcb.
